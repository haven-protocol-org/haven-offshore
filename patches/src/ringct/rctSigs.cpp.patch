--- ringct/rctSigs.cpp.orig	2020-08-14 16:26:34.777541400 +0200
+++ ringct/rctSigs.cpp	2020-08-14 19:33:04.312275500 +0200
@@ -36,6 +36,8 @@
 #include "rctSigs.h"
 #include "bulletproofs.h"
 #include "cryptonote_basic/cryptonote_format_utils.h"
+#include "cryptonote_config.h"
+#include <boost/multiprecision/cpp_int.hpp>
 
 using namespace crypto;
 using namespace std;
@@ -47,7 +49,7 @@
 
 namespace
 {
-    rct::Bulletproof make_dummy_bulletproof(const std::vector<uint64_t> &outamounts, rct::keyV &C, rct::keyV &masks)
+  rct::Bulletproof make_dummy_bulletproof(const std::vector<uint64_t> &outamounts, rct::keyV &C, rct::keyV &masks)
     {
         const size_t n_outs = outamounts.size();
         const rct::key I = rct::identity();
@@ -77,9 +79,140 @@
 
         return rct::Bulletproof{rct::keyV(n_outs, I), I, I, I, I, I, I, rct::keyV(nrl, I), rct::keyV(nrl, I), I, I, I};
     }
+  
+  rct::Bulletproof make_dummy_bulletproofXHV(const std::vector<std::pair<uint64_t, uint64_t>> &outamounts, rct::keyV &C, rct::keyV &masks)
+    {
+        const size_t n_outs = outamounts.size();
+        const rct::key I = rct::identity();
+        size_t nrl = 0;
+        while ((1u << nrl) < n_outs)
+          ++nrl;
+        nrl += 6;
+
+        C.resize(n_outs);
+        masks.resize(n_outs);
+        for (size_t i = 0; i < n_outs; ++i)
+        {
+            masks[i] = I;
+            rct::key sv8, sv;
+            sv = rct::zero();
+	    uint64_t amount_nonzero = (outamounts[i].first == 0 ? outamounts[i].second : outamounts[i].first);
+            sv.bytes[0] = amount_nonzero & 255;
+            sv.bytes[1] = (amount_nonzero >> 8) & 255;
+            sv.bytes[2] = (amount_nonzero >> 16) & 255;
+            sv.bytes[3] = (amount_nonzero >> 24) & 255;
+            sv.bytes[4] = (amount_nonzero >> 32) & 255;
+            sv.bytes[5] = (amount_nonzero >> 40) & 255;
+            sv.bytes[6] = (amount_nonzero >> 48) & 255;
+            sv.bytes[7] = (amount_nonzero >> 56) & 255;
+            sc_mul(sv8.bytes, sv.bytes, rct::INV_EIGHT.bytes);
+            rct::addKeys2(C[i], rct::INV_EIGHT, sv8, rct::H);
+        }
+
+        return rct::Bulletproof{rct::keyV(n_outs, I), I, I, I, I, I, I, rct::keyV(nrl, I), rct::keyV(nrl, I), I, I, I};
+    }
+
+  void sc_div(unsigned char *s, const unsigned char *a, const unsigned char *b) {
+
+    ge_p3 ge_b;
+    ge_frombytes_vartime(&ge_b, b);
+    ge_p3 ge_out = ge_b;
+    fe_invert(ge_out.Y, ge_b.Y);
+    //fe_invert(ge_out.T, ge_b.T);
+    rct::key foo;
+    ge_p3_tobytes(foo.bytes, &ge_out);
+    sc_mul(s, a, foo.bytes);
+  }
+
+  rct::key sm(rct::key y, int n, const rct::key &x)
+  {
+    while (n--)
+      sc_mul(y.bytes, y.bytes, y.bytes);
+    sc_mul(y.bytes, y.bytes, x.bytes);
+    return y;
+  }
+
+  /* Compute the inverse of a scalar, the clever way */
+  rct::key invert(const rct::key &x)
+  {
+    rct::key _1, _10, _100, _11, _101, _111, _1001, _1011, _1111;
+
+    _1 = x;
+    sc_mul(_10.bytes, _1.bytes, _1.bytes);
+    sc_mul(_100.bytes, _10.bytes, _10.bytes);
+    sc_mul(_11.bytes, _10.bytes, _1.bytes);
+    sc_mul(_101.bytes, _10.bytes, _11.bytes);
+    sc_mul(_111.bytes, _10.bytes, _101.bytes);
+    sc_mul(_1001.bytes, _10.bytes, _111.bytes);
+    sc_mul(_1011.bytes, _10.bytes, _1001.bytes);
+    sc_mul(_1111.bytes, _100.bytes, _1011.bytes);
+
+    rct::key inv;
+    sc_mul(inv.bytes, _1111.bytes, _1.bytes);
+
+    inv = sm(inv, 123 + 3, _101);
+    inv = sm(inv, 2 + 2, _11);
+    inv = sm(inv, 1 + 4, _1111);
+    inv = sm(inv, 1 + 4, _1111);
+    inv = sm(inv, 4, _1001);
+    inv = sm(inv, 2, _11);
+    inv = sm(inv, 1 + 4, _1111);
+    inv = sm(inv, 1 + 3, _101);
+    inv = sm(inv, 3 + 3, _101);
+    inv = sm(inv, 3, _111);
+    inv = sm(inv, 1 + 4, _1111);
+    inv = sm(inv, 2 + 3, _111);
+    inv = sm(inv, 2 + 2, _11);
+    inv = sm(inv, 1 + 4, _1011);
+    inv = sm(inv, 2 + 4, _1011);
+    inv = sm(inv, 6 + 4, _1001);
+    inv = sm(inv, 2 + 2, _11);
+    inv = sm(inv, 3 + 2, _11);
+    inv = sm(inv, 3 + 2, _11);
+    inv = sm(inv, 1 + 4, _1001);
+    inv = sm(inv, 1 + 3, _111);
+    inv = sm(inv, 2 + 4, _1111);
+    inv = sm(inv, 1 + 4, _1011);
+    inv = sm(inv, 3, _101);
+    inv = sm(inv, 2 + 4, _1111);
+    inv = sm(inv, 3, _101);
+    inv = sm(inv, 1 + 2, _11);
+
+#ifdef DEBUG_BP
+    rct::key tmp;
+    sc_mul(tmp.bytes, inv.bytes, x.bytes);
+    CHECK_AND_ASSERT_THROW_MES(tmp == rct::identity(), "invert failed");
+#endif
+    return inv;
+  }
+  
 }
 
 namespace rct {
+
+  Bulletproof proveRangeBulletproofXHV(keyV &C, keyV &masks, const std::vector<std::pair<uint64_t, uint64_t>> &amounts, epee::span<const key> sk, hw::device &hwdev)
+    {
+        CHECK_AND_ASSERT_THROW_MES(amounts.size() == sk.size(), "Invalid amounts/sk sizes");
+        masks.resize(amounts.size());
+        for (size_t i = 0; i < masks.size(); ++i)
+            masks[i] = hwdev.genCommitmentMask(sk[i]);
+	// HERE BE DRAGONS!!!
+	// NEAC: this might not work, depending on if we can ignore zero amounts in either currency
+	// NEAC: we KNOW that only one amount will be nonzero (either XHV or USD)...
+	std::vector<uint64_t> amounts_nonzero;
+	for (size_t i=0; i < amounts.size(); ++i) {
+	  if (amounts[i].first == 0)
+	    amounts_nonzero.push_back(amounts[i].second);
+	  else
+	    amounts_nonzero.push_back(amounts[i].first);
+	}
+	// LAND AHOY!!!
+        Bulletproof proof = bulletproof_PROVE(amounts_nonzero, masks);
+        CHECK_AND_ASSERT_THROW_MES(proof.V.size() == amounts_nonzero.size(), "V does not have the expected size");
+        C = proof.V;
+        return proof;
+    }
+
     Bulletproof proveRangeBulletproof(keyV &C, keyV &masks, const std::vector<uint64_t> &amounts, epee::span<const key> sk, hw::device &hwdev)
     {
         CHECK_AND_ASSERT_THROW_MES(amounts.size() == sk.size(), "Invalid amounts/sk sizes");
@@ -92,6 +225,13 @@
         return proof;
     }
 
+    bool verBulletproofXHV(const Bulletproof &proof)
+    {
+      try { return bulletproof_VERIFY(proof); }
+      // we can get deep throws from ge_frombytes_vartime if input isn't valid
+      catch (...) { return false; }
+    }
+
     bool verBulletproof(const Bulletproof &proof)
     {
       try { return bulletproof_VERIFY(proof); }
@@ -164,6 +304,171 @@
       }
       return verifyBorromean(bb, P1_p3, P2_p3);
     }
+// Generate a CLSAG signature
+    // See paper by Goodell et al. (https://eprint.iacr.org/2019/654)
+    //
+    // The keys are set as follows:
+    //   P[l] == p*G
+    //   C[l] == z*G
+    //   C[i] == C_nonzero[i] - C_offset (for hashing purposes) for all i
+    clsag CLSAG_Gen(const key &message, const keyV & P, const key & p, const keyV & C, const key & z, const keyV & C_nonzero, const key & C_offset, const unsigned int l, const multisig_kLRki *kLRki, key *mscout, key *mspout) {
+        clsag sig;
+        size_t n = P.size(); // ring size
+        CHECK_AND_ASSERT_THROW_MES(n == C.size(), "Signing and commitment key vector sizes must match!");
+        CHECK_AND_ASSERT_THROW_MES(n == C_nonzero.size(), "Signing and commitment key vector sizes must match!");
+        CHECK_AND_ASSERT_THROW_MES(l < n, "Signing index out of range!");
+        CHECK_AND_ASSERT_THROW_MES((kLRki && mscout) || (!kLRki && !mscout), "Only one of kLRki/mscout is present");
+        CHECK_AND_ASSERT_THROW_MES((mscout && mspout) || !kLRki, "Multisig pointers are not all present");
+
+        // Key images
+        ge_p3 H_p3;
+        hash_to_p3(H_p3,P[l]);
+        key H;
+        ge_p3_tobytes(H.bytes,&H_p3);
+
+        key D;
+        scalarmultKey(D,H,z);
+
+        // Multisig
+        if (kLRki)
+        {
+            sig.I = kLRki->ki;
+        }
+        else
+        {
+            scalarmultKey(sig.I,H,p);
+        }
+
+        geDsmp I_precomp;
+        geDsmp D_precomp;
+        precomp(I_precomp.k,sig.I);
+        precomp(D_precomp.k,D);
+
+        // Offset key image
+        scalarmultKey(sig.D,D,INV_EIGHT);
+
+        // Initial values
+        key a;
+        key aG;
+        key aH;
+        skpkGen(a,aG);
+        scalarmultKey(aH,H,a);
+
+        // Aggregation hashes
+        keyV mu_P_to_hash(2*n+4); // domain, I, D, P, C, C_offset
+        keyV mu_C_to_hash(2*n+4); // domain, I, D, P, C, C_offset
+        sc_0(mu_P_to_hash[0].bytes);
+        memcpy(mu_P_to_hash[0].bytes,config::HASH_KEY_CLSAG_AGG_0,sizeof(config::HASH_KEY_CLSAG_AGG_0)-1);
+        sc_0(mu_C_to_hash[0].bytes);
+        memcpy(mu_C_to_hash[0].bytes,config::HASH_KEY_CLSAG_AGG_1,sizeof(config::HASH_KEY_CLSAG_AGG_1)-1);
+        for (size_t i = 1; i < n+1; ++i) {
+            mu_P_to_hash[i] = P[i-1];
+            mu_C_to_hash[i] = P[i-1];
+        }
+        for (size_t i = n+1; i < 2*n+1; ++i) {
+            mu_P_to_hash[i] = C_nonzero[i-n-1];
+            mu_C_to_hash[i] = C_nonzero[i-n-1];
+        }
+        mu_P_to_hash[2*n+1] = sig.I;
+        mu_P_to_hash[2*n+2] = sig.D;
+        mu_P_to_hash[2*n+3] = C_offset;
+        mu_C_to_hash[2*n+1] = sig.I;
+        mu_C_to_hash[2*n+2] = sig.D;
+        mu_C_to_hash[2*n+3] = C_offset;
+        key mu_P, mu_C;
+        mu_P = hash_to_scalar(mu_P_to_hash);
+        mu_C = hash_to_scalar(mu_C_to_hash);
+
+        // Initial commitment
+        keyV c_to_hash(2*n+5); // domain, P, C, C_offset, message, aG, aH
+        key c;
+        sc_0(c_to_hash[0].bytes);
+        memcpy(c_to_hash[0].bytes,config::HASH_KEY_CLSAG_ROUND,sizeof(config::HASH_KEY_CLSAG_ROUND)-1);
+        for (size_t i = 1; i < n+1; ++i)
+        {
+            c_to_hash[i] = P[i-1];
+            c_to_hash[i+n] = C_nonzero[i-1];
+        }
+        c_to_hash[2*n+1] = C_offset;
+        c_to_hash[2*n+2] = message;
+
+        // Multisig data is present
+        if (kLRki)
+        {
+            a = kLRki->k;
+            c_to_hash[2*n+3] = kLRki->L;
+            c_to_hash[2*n+4] = kLRki->R;
+        }
+        else
+        {
+            c_to_hash[2*n+3] = aG;
+            c_to_hash[2*n+4] = aH;
+        }
+        c = hash_to_scalar(c_to_hash);
+        
+        size_t i;
+        i = (l + 1) % n;
+        if (i == 0)
+            copy(sig.c1, c);
+
+        // Decoy indices
+        sig.s = keyV(n);
+        key c_new;
+        key L;
+        key R;
+        key c_p; // = c[i]*mu_P
+        key c_c; // = c[i]*mu_C
+        geDsmp P_precomp;
+        geDsmp C_precomp;
+        geDsmp H_precomp;
+        ge_p3 Hi_p3;
+
+        while (i != l) {
+            sig.s[i] = skGen();
+            sc_0(c_new.bytes);
+            sc_mul(c_p.bytes,mu_P.bytes,c.bytes);
+            sc_mul(c_c.bytes,mu_C.bytes,c.bytes);
+
+            // Precompute points
+            precomp(P_precomp.k,P[i]);
+            precomp(C_precomp.k,C[i]);
+
+            // Compute L
+            addKeys_aGbBcC(L,sig.s[i],c_p,P_precomp.k,c_c,C_precomp.k);
+
+            // Compute R
+            hash_to_p3(Hi_p3,P[i]);
+            ge_dsm_precomp(H_precomp.k, &Hi_p3);
+            addKeys_aAbBcC(R,sig.s[i],H_precomp.k,c_p,I_precomp.k,c_c,D_precomp.k);
+
+            c_to_hash[2*n+3] = L;
+            c_to_hash[2*n+4] = R;
+            c_new = hash_to_scalar(c_to_hash);
+            copy(c,c_new);
+            
+            i = (i + 1) % n;
+            if (i == 0)
+                copy(sig.c1,c);
+        }
+
+        // Compute final scalar
+        key s0_p_mu_P;
+        sc_mul(s0_p_mu_P.bytes,mu_P.bytes,p.bytes);
+        key s0_add_z_mu_C;
+        sc_muladd(s0_add_z_mu_C.bytes,mu_C.bytes,z.bytes,s0_p_mu_P.bytes);
+        sc_mulsub(sig.s[l].bytes,c.bytes,s0_add_z_mu_C.bytes,a.bytes);
+
+        if (mscout)
+          *mscout = c;
+        if (mspout)
+          *mspout = mu_P;
+
+        return sig;
+    }
+
+    clsag CLSAG_Gen(const key &message, const keyV & P, const key & p, const keyV & C, const key & z, const keyV & C_nonzero, const key & C_offset, const unsigned int l) {
+        return CLSAG_Gen(message, P, p, C, z, C_nonzero, C_offset, l, NULL, NULL, NULL);
+    }
 
     // MLSAG signatures
     // See paper by Noether (https://eprint.iacr.org/2015/1098)
@@ -366,6 +671,11 @@
         return sig;
     }
 
+  rangeSig proveRange(key & C, key & mask, const std::pair<xmr_amount,xmr_amount> & amount_pair) {
+    rangeSig sig;
+    return sig;
+  }
+  
     //proveRange and verRange
     //proveRange gives C, and mask such that \sumCi = C
     //   c.f. https://eprint.iacr.org/2015/1098 section 5.1
@@ -427,7 +737,7 @@
       hashes.push_back(hash2rct(h));
 
       keyV kv;
-      if (rv.type == RCTTypeBulletproof || rv.type == RCTTypeBulletproof2)
+      if (rv.type == RCTTypeBulletproof || rv.type == RCTTypeBulletproof2 || rv.type == RCTTypeCLSAG)
       {
         kv.reserve((6*2+9) * rv.p.bulletproofs.size());
         for (const auto &p: rv.p.bulletproofs)
@@ -555,6 +865,37 @@
         return result;
     }
 
+    clsag proveRctCLSAGSimple(const key &message, const ctkeyV &pubs, const ctkey &inSk, const key &a, const key &Cout, const multisig_kLRki *kLRki, key *mscout, key *mspout, unsigned int index, hw::device &hwdev) {
+        //setup vars
+        size_t rows = 1;
+        size_t cols = pubs.size();
+        CHECK_AND_ASSERT_THROW_MES(cols >= 1, "Empty pubs");
+        CHECK_AND_ASSERT_THROW_MES((kLRki && mscout) || (!kLRki && !mscout), "Only one of kLRki/mscout is present");
+        keyV tmp(rows + 1);
+        keyV sk(rows + 1);
+        size_t i;
+        keyM M(cols, tmp);
+
+        keyV P, C, C_nonzero;
+        P.reserve(pubs.size());
+        C.reserve(pubs.size());
+        C_nonzero.reserve(pubs.size());
+        for (const ctkey &k: pubs)
+        {
+            P.push_back(k.dest);
+            C_nonzero.push_back(k.mask);
+            rct::key tmp;
+            subKeys(tmp, k.mask, Cout);
+            C.push_back(tmp);
+        }
+
+        sk[0] = copy(inSk.dest);
+        sc_sub(sk[1].bytes, inSk.mask.bytes, a.bytes);
+        clsag result = CLSAG_Gen(message, P, sk[0], C, sk[1], C_nonzero, Cout, index, kLRki, mscout, mspout);
+        memwipe(&sk[0], sizeof(key));
+        return result;
+    }
+
 
     //Ring-ct MG sigs
     //Prove: 
@@ -634,6 +975,120 @@
         catch (...) { return false; }
     }
 
+    bool verRctCLSAGSimple(const key &message, const clsag &sig, const ctkeyV & pubs, const key & C_offset) {
+        try
+        {
+            PERF_TIMER(verRctCLSAGSimple);
+            const size_t n = pubs.size();
+
+            // Check data
+            CHECK_AND_ASSERT_MES(n >= 1, false, "Empty pubs");
+            CHECK_AND_ASSERT_MES(n == sig.s.size(), false, "Signature scalar vector is the wrong size!");
+            for (size_t i = 0; i < n; ++i)
+                CHECK_AND_ASSERT_MES(sc_check(sig.s[i].bytes) == 0, false, "Bad signature scalar!");
+            CHECK_AND_ASSERT_MES(sc_check(sig.c1.bytes) == 0, false, "Bad signature commitment!");
+            CHECK_AND_ASSERT_MES(!(sig.I == rct::identity()), false, "Bad key image!");
+
+            // Cache commitment offset for efficient subtraction later
+            ge_p3 C_offset_p3;
+            CHECK_AND_ASSERT_MES(ge_frombytes_vartime(&C_offset_p3, C_offset.bytes) == 0, false, "point conv failed");
+            ge_cached C_offset_cached;
+            ge_p3_to_cached(&C_offset_cached, &C_offset_p3);
+
+            // Prepare key images
+            key c = copy(sig.c1);
+            key D_8 = scalarmult8(sig.D);
+            CHECK_AND_ASSERT_MES(!(D_8 == rct::identity()), false, "Bad auxiliary key image!");
+            geDsmp I_precomp;
+            geDsmp D_precomp;
+            precomp(I_precomp.k,sig.I);
+            precomp(D_precomp.k,D_8);
+
+            // Aggregation hashes
+            keyV mu_P_to_hash(2*n+4); // domain, I, D, P, C, C_offset
+            keyV mu_C_to_hash(2*n+4); // domain, I, D, P, C, C_offset
+            sc_0(mu_P_to_hash[0].bytes);
+            memcpy(mu_P_to_hash[0].bytes,config::HASH_KEY_CLSAG_AGG_0,sizeof(config::HASH_KEY_CLSAG_AGG_0)-1);
+            sc_0(mu_C_to_hash[0].bytes);
+            memcpy(mu_C_to_hash[0].bytes,config::HASH_KEY_CLSAG_AGG_1,sizeof(config::HASH_KEY_CLSAG_AGG_1)-1);
+            for (size_t i = 1; i < n+1; ++i) {
+                mu_P_to_hash[i] = pubs[i-1].dest;
+                mu_C_to_hash[i] = pubs[i-1].dest;
+            }
+            for (size_t i = n+1; i < 2*n+1; ++i) {
+                mu_P_to_hash[i] = pubs[i-n-1].mask;
+                mu_C_to_hash[i] = pubs[i-n-1].mask;
+            }
+            mu_P_to_hash[2*n+1] = sig.I;
+            mu_P_to_hash[2*n+2] = sig.D;
+            mu_P_to_hash[2*n+3] = C_offset;
+            mu_C_to_hash[2*n+1] = sig.I;
+            mu_C_to_hash[2*n+2] = sig.D;
+            mu_C_to_hash[2*n+3] = C_offset;
+            key mu_P, mu_C;
+            mu_P = hash_to_scalar(mu_P_to_hash);
+            mu_C = hash_to_scalar(mu_C_to_hash);
+
+            // Set up round hash
+            keyV c_to_hash(2*n+5); // domain, P, C, C_offset, message, L, R
+            sc_0(c_to_hash[0].bytes);
+            memcpy(c_to_hash[0].bytes,config::HASH_KEY_CLSAG_ROUND,sizeof(config::HASH_KEY_CLSAG_ROUND)-1);
+            for (size_t i = 1; i < n+1; ++i)
+            {
+                c_to_hash[i] = pubs[i-1].dest;
+                c_to_hash[i+n] = pubs[i-1].mask;
+            }
+            c_to_hash[2*n+1] = C_offset;
+            c_to_hash[2*n+2] = message;
+            key c_p; // = c[i]*mu_P
+            key c_c; // = c[i]*mu_C
+            key c_new;
+            key L;
+            key R;
+            geDsmp P_precomp;
+            geDsmp C_precomp;
+            geDsmp H_precomp;
+            size_t i = 0;
+            ge_p3 hash8_p3;
+            geDsmp hash_precomp;
+            ge_p3 temp_p3;
+            ge_p1p1 temp_p1;
+
+            while (i < n) {
+                sc_0(c_new.bytes);
+                sc_mul(c_p.bytes,mu_P.bytes,c.bytes);
+                sc_mul(c_c.bytes,mu_C.bytes,c.bytes);
+
+                // Precompute points for L/R
+                precomp(P_precomp.k,pubs[i].dest);
+
+                CHECK_AND_ASSERT_MES(ge_frombytes_vartime(&temp_p3, pubs[i].mask.bytes) == 0, false, "point conv failed");
+                ge_sub(&temp_p1,&temp_p3,&C_offset_cached);
+                ge_p1p1_to_p3(&temp_p3,&temp_p1);
+                ge_dsm_precomp(C_precomp.k,&temp_p3);
+
+                // Compute L
+                addKeys_aGbBcC(L,sig.s[i],c_p,P_precomp.k,c_c,C_precomp.k);
+
+                // Compute R
+                hash_to_p3(hash8_p3,pubs[i].dest);
+                ge_dsm_precomp(hash_precomp.k, &hash8_p3);
+                addKeys_aAbBcC(R,sig.s[i],hash_precomp.k,c_p,I_precomp.k,c_c,D_precomp.k);
+
+                c_to_hash[2*n+3] = L;
+                c_to_hash[2*n+4] = R;
+                c_new = hash_to_scalar(c_to_hash);
+                CHECK_AND_ASSERT_MES(!(c_new == rct::zero()), false, "Bad signature hash");
+                copy(c,c_new);
+
+                i = i + 1;
+            }
+            sc_sub(c_new.bytes,c.bytes,sig.c1.bytes);
+            return sc_isnonzero(c_new.bytes) == 0;
+        }
+        catch (...) { return false; }
+    }
+
 
     //These functions get keys from blockchain
     //replace these when connecting blockchain
@@ -695,7 +1150,7 @@
     //   must know the destination private key to find the correct amount, else will return a random number
     //   Note: For txn fees, the last index in the amounts vector should contain that
     //   Thus the amounts vector will be "one" longer than the destinations vectort
-    rctSig genRct(const key &message, const ctkeyV & inSk, const keyV & destinations, const vector<xmr_amount> & amounts, const ctkeyM &mixRing, const keyV &amount_keys, const multisig_kLRki *kLRki, multisig_out *msout, unsigned int index, ctkeyV &outSk, const RCTConfig &rct_config, hw::device &hwdev) {
+  rctSig genRct(const key &message, const ctkeyM & inSk, const keyV & destinations, const vector<pair<xmr_amount,xmr_amount>> & amounts, const ctkeyM &mixRing, const keyV &amount_keys, const multisig_kLRki *kLRki, multisig_out *msout, unsigned int index, ctkeyV &outSk, const RCTConfig &rct_config, hw::device &hwdev) {
         CHECK_AND_ASSERT_THROW_MES(amounts.size() == destinations.size() || amounts.size() == destinations.size() + 1, "Different number of amounts/destinations");
         CHECK_AND_ASSERT_THROW_MES(amount_keys.size() == destinations.size(), "Different number of amount_keys/destinations");
         CHECK_AND_ASSERT_THROW_MES(index < mixRing.size(), "Bad index into mixRing");
@@ -712,6 +1167,20 @@
         rv.p.rangeSigs.resize(destinations.size());
         rv.ecdhInfo.resize(destinations.size());
 
+	// HERE BE DRAGONS!!!
+	// NEAC: convert incoming amount vector/pairs into discrete vectors
+	std::vector<xmr_amount> amounts_xhv, amounts_usd;
+        for (size_t i = 0 ; i < amounts.size() - 1; i++) {
+	  amounts_xhv.push_back(amounts[i].first);
+	  amounts_usd.push_back(amounts[i].second);
+	}
+	ctkeyV inSk_xhv, inSk_usd;
+	for (size_t i=0; i<inSk.size(); i++) {
+	  inSk_xhv.push_back(inSk[i].front());
+	  inSk_usd.push_back(inSk[i].back());
+	}
+	// LAND AHOY!!!
+	
         size_t i = 0;
         keyV masks(destinations.size()); //sk mask..
         outSk.resize(destinations.size());
@@ -719,20 +1188,32 @@
             //add destination to sig
             rv.outPk[i].dest = copy(destinations[i]);
             //compute range proof
-            rv.p.rangeSigs[i] = proveRange(rv.outPk[i].mask, outSk[i].mask, amounts[i]);
+	    // HERE BE DRAGONS!!!
+	    // NEAC: need to change the type to accommodate multiple amounts - one for each currency
+            //rv.p.rangeSigs[i] = proveRange(rv.outPk[i].mask, outSk[i].mask, amounts[i]);
+            rv.p.rangeSigs[i] = proveRange(rv.outPk[i].mask, outSk[i].mask, amounts[i].first);
+	    // LAND AHOY!!!
             #ifdef DBG
             CHECK_AND_ASSERT_THROW_MES(verRange(rv.outPk[i].mask, rv.p.rangeSigs[i]), "verRange failed on newly created proof");
             #endif
             //mask amount and mask
             rv.ecdhInfo[i].mask = copy(outSk[i].mask);
-            rv.ecdhInfo[i].amount = d2h(amounts[i]);
-            hwdev.ecdhEncode(rv.ecdhInfo[i], amount_keys[i], rv.type == RCTTypeBulletproof2);
+	    // HERE BE DRAGONS!!!
+	    // NEAC: need to change the type to accommodate multiple amounts - one for each currency
+            //rv.ecdhInfo[i].amount = d2h(amounts[i]);
+            rv.ecdhInfo[i].amount = d2h(amounts[i].first);
+	    // LAND AHOY!!!
+            hwdev.ecdhEncode(rv.ecdhInfo[i], amount_keys[i], rv.type == RCTTypeBulletproof2 || rv.type == RCTTypeCLSAG);
         }
 
         //set txn fee
         if (amounts.size() > destinations.size())
         {
-          rv.txnFee = amounts[destinations.size()];
+	  // NEAC: need to change the type to accommodate multiple amounts - one for each currency
+	  //rv.ecdhInfo[i].amount = d2h(amounts[i]);
+          //rv.txnFee = amounts[destinations.size()];
+          rv.txnFee = amounts[destinations.size()].first;
+	  // LAND AHOY!!!
         }
         else
         {
@@ -743,11 +1224,14 @@
         rv.mixRing = mixRing;
         if (msout)
           msout->c.resize(1);
-        rv.p.MGs.push_back(proveRctMG(get_pre_mlsag_hash(rv, hwdev), rv.mixRing, inSk, outSk, rv.outPk, kLRki, msout ? &msout->c[0] : NULL, index, txnFeeKey,hwdev));
+	// HERE BE DRAGONS!!!
+	// NEAC: call this twice - once for each currency
+        rv.p.MGs.push_back(proveRctMG(get_pre_mlsag_hash(rv, hwdev), rv.mixRing, inSk_xhv, outSk, rv.outPk, kLRki, msout ? &msout->c[0] : NULL, index, txnFeeKey,hwdev));
+	// LAND AHOY!!!
         return rv;
     }
 
-    rctSig genRct(const key &message, const ctkeyV & inSk, const ctkeyV  & inPk, const keyV & destinations, const vector<xmr_amount> & amounts, const keyV &amount_keys, const multisig_kLRki *kLRki, multisig_out *msout, const int mixin, const RCTConfig &rct_config, hw::device &hwdev) {
+  rctSig genRct(const key &message, const ctkeyM & inSk, const ctkeyV  & inPk, const keyV & destinations, const vector<pair<xmr_amount,xmr_amount>> & amounts, const keyV &amount_keys, const multisig_kLRki *kLRki, multisig_out *msout, const int mixin, const RCTConfig &rct_config, hw::device &hwdev) {
         unsigned int index;
         ctkeyM mixRing;
         ctkeyV outSk;
@@ -757,7 +1241,7 @@
     
     //RCT simple    
     //for post-rct only
-    rctSig genRctSimple(const key &message, const ctkeyV & inSk, const keyV & destinations, const vector<xmr_amount> &inamounts, const vector<xmr_amount> &outamounts, xmr_amount txnFee, const ctkeyM & mixRing, const keyV &amount_keys, const std::vector<multisig_kLRki> *kLRki, multisig_out *msout, const std::vector<unsigned int> & index, ctkeyV &outSk, const RCTConfig &rct_config, hw::device &hwdev) {
+  rctSig genRctSimple(const key &message, const ctkeyM & inSk, const keyV & destinations, const vector<std::pair<xmr_amount,xmr_amount>> &inamounts, const vector<std::pair<xmr_amount,xmr_amount>> &outamounts, xmr_amount txnFee, xmr_amount txnFee_usd, xmr_amount txnOffshoreFee, xmr_amount txnOffshoreFee_usd, const ctkeyM & mixRing, const keyV &amount_keys, const std::vector<multisig_kLRki> *kLRki, multisig_out *msout, const std::vector<unsigned int> & index, ctkeyV &outSk, const RCTConfig &rct_config, hw::device &hwdev, const offshore::pricing_record pr) {
         const bool bulletproof = rct_config.range_proof_type != RangeProofBorromean;
         CHECK_AND_ASSERT_THROW_MES(inamounts.size() > 0, "Empty inamounts");
         CHECK_AND_ASSERT_THROW_MES(inamounts.size() == inSk.size(), "Different number of inamounts/inSk");
@@ -773,10 +1257,65 @@
           CHECK_AND_ASSERT_THROW_MES(kLRki->size() == inamounts.size(), "Mismatched kLRki/inamounts sizes");
         }
 
+	// HERE BE DRAGONS!!!
+	// NEAC: convert incoming amount vector/pairs into discrete vectors
+	bool xhv_sent = false, usd_sent = false; 
+	std::vector<xmr_amount> inamounts_xhv, inamounts_usd, outamounts_xhv, outamounts_usd, outamounts_nonzero;
+        for (size_t i = 0 ; i < inamounts.size(); i++) {
+	  inamounts_xhv.push_back(inamounts[i].first);
+	  inamounts_usd.push_back(inamounts[i].second);
+	  if (inamounts[i].first != 0) xhv_sent = true;
+	  if (inamounts[i].second != 0) usd_sent = true;
+	}
+	bool xhv_received = false, usd_received = false; 
+        for (size_t i = 0 ; i < outamounts.size(); i++) {
+	  outamounts_xhv.push_back(outamounts[i].first);
+	  outamounts_usd.push_back(outamounts[i].second);
+	  if (outamounts[i].first != 0) xhv_received = true;
+	  if (outamounts[i].second != 0) usd_received = true;
+	}
+	ctkeyV inSk_xhv, inSk_usd;
+	for (size_t i=0; i<inSk.size(); i++) {
+	  inSk_xhv.push_back(inSk[i].front());
+	  inSk_usd.push_back(inSk[i].back());
+	}
+	for (size_t i=0; i < outamounts.size(); ++i) {
+	  if ((outamounts[i].first == 0) && (outamounts[i].second != 0))
+	    outamounts_nonzero.push_back(outamounts[i].second);
+	  else
+	    outamounts_nonzero.push_back(outamounts[i].first);
+	}
+
+	bool offshore = (xhv_sent && !usd_sent && usd_received && xhv_received);
+	bool onshore = (usd_sent && !xhv_sent && usd_received && xhv_received);
+	bool offshore_to_offshore = (usd_sent && !xhv_sent && usd_received && !xhv_received);
+	// LAND AHOY!!!
+	
         rctSig rv;
-        rv.type = bulletproof ? (rct_config.bp_version == 0 || rct_config.bp_version >= 2 ? RCTTypeBulletproof2 : RCTTypeBulletproof) : RCTTypeSimple;
+        if (bulletproof)
+        {
+          switch (rct_config.bp_version)
+          {
+            case 0:
+            case 3:
+              rv.type = RCTTypeCLSAG;
+              break;
+            case 2:
+              rv.type = RCTTypeBulletproof2;
+              break;
+            case 1:
+              rv.type = RCTTypeBulletproof;
+              break;
+            default:
+              ASSERT_MES_AND_THROW("Unsupported BP version: " << rct_config.bp_version);
+          }
+        }
+        else
+          rv.type = RCTTypeSimple;
+
         rv.message = message;
         rv.outPk.resize(destinations.size());
+        rv.outPk_usd.resize(destinations.size());
         if (!bulletproof)
           rv.p.rangeSigs.resize(destinations.size());
         rv.ecdhInfo.resize(destinations.size());
@@ -787,15 +1326,27 @@
         for (i = 0; i < destinations.size(); i++) {
 
             //add destination to sig
-            rv.outPk[i].dest = copy(destinations[i]);
+            rv.outPk[i].dest = rv.outPk_usd[i].dest = copy(destinations[i]);
             //compute range proof
-            if (!bulletproof)
-              rv.p.rangeSigs[i] = proveRange(rv.outPk[i].mask, outSk[i].mask, outamounts[i]);
+            if (!bulletproof) {
+	      // HERE BE DRAGONS!!!
+	      // NEAC: need to change the type to accommodate multiple rangeSigs - one for each currency
+              rv.p.rangeSigs[i] = proveRange(rv.outPk[i].mask, outSk[i].mask, outamounts_xhv[i]);
+	      // LAND AHOY!!!
+	    }
             #ifdef DBG
-            if (!bulletproof)
-                CHECK_AND_ASSERT_THROW_MES(verRange(rv.outPk[i].mask, rv.p.rangeSigs[i]), "verRange failed on newly created proof");
+            if (!bulletproof) {
+	      // HERE BE DRAGONS!!!
+	      // NEAC: need to change the type to accommodate multiple rangeSigs - one for each currency
+	      CHECK_AND_ASSERT_THROW_MES(verRange(rv.outPk[i].mask, rv.p.rangeSigs[i]), "verRange failed on newly created proof");
+	      // LAND AHOY!!!
+	    }
             #endif
         }
+	
+	key zerokey;
+	memwipe(&zerokey, sizeof(key));
+	key zeromask = rct::scalarmult8(zerokey);
 
         rv.p.bulletproofs.clear();
         if (bulletproof)
@@ -804,24 +1355,34 @@
             size_t amounts_proved = 0;
             if (rct_config.range_proof_type == RangeProofPaddedBulletproof)
             {
-                rct::keyV C, masks;
+	        rct::keyV C, D, masks_xhv, masks_usd;
                 if (hwdev.get_mode() == hw::device::TRANSACTION_CREATE_FAKE)
                 {
-                    // use a fake bulletproof for speed
-                    rv.p.bulletproofs.push_back(make_dummy_bulletproof(outamounts, C, masks));
+		  // use a fake bulletproof for speed
+		  rv.p.bulletproofs.push_back(make_dummy_bulletproof(outamounts_nonzero, C, masks));
                 }
                 else
                 {
-                    const epee::span<const key> keys{&amount_keys[0], amount_keys.size()};
-                    rv.p.bulletproofs.push_back(proveRangeBulletproof(C, masks, outamounts, keys, hwdev));
-                    #ifdef DBG
-                    CHECK_AND_ASSERT_THROW_MES(verBulletproof(rv.p.bulletproofs.back()), "verBulletproof failed on newly created proof");
-                    #endif
+		  const epee::span<const key> keys{&amount_keys[0], amount_keys.size()};
+		  rv.p.bulletproofs.push_back(proveRangeBulletproof(C, masks, outamounts_nonzero, keys, hwdev));
+		  // HERE BE DRAGONS!!!
+		  // NEAC: disable these checks again in the final builds
+                  //#ifdef DBG
+		  CHECK_AND_ASSERT_THROW_MES(verBulletproof(rv.p.bulletproofs.back()), "verBulletproof failed on newly created proof");
+                  //#endif
+		  // LAND AHOY!!!
                 }
+
                 for (i = 0; i < outamounts.size(); ++i)
                 {
+		  if ((outamounts[i].first == 0) && (outamounts[i].second != 0)) {
+                    rv.outPk[i].mask = zeromask;
+                    rv.outPk_usd[i].mask = rct::scalarmult8(C[i]);
+		  } else {
                     rv.outPk[i].mask = rct::scalarmult8(C[i]);
-                    outSk[i].mask = masks[i];
+                    rv.outPk_usd[i].mask = zeromask;
+		  }
+		  outSk[i].mask = masks[i];
                 }
             }
             else while (amounts_proved < n_amounts)
@@ -831,71 +1392,133 @@
                   while (batch_size * 2 + amounts_proved <= n_amounts && batch_size * 2 <= BULLETPROOF_MAX_OUTPUTS)
                     batch_size *= 2;
                 rct::keyV C, masks;
-                std::vector<uint64_t> batch_amounts(batch_size);
-                for (i = 0; i < batch_size; ++i)
+                std::vector<std::pair<uint64_t, uint64_t>> batch_amounts(batch_size);
+                for (i = 0; i < batch_size; ++i) {
                   batch_amounts[i] = outamounts[i + amounts_proved];
+		}
                 if (hwdev.get_mode() == hw::device::TRANSACTION_CREATE_FAKE)
                 {
                     // use a fake bulletproof for speed
-                    rv.p.bulletproofs.push_back(make_dummy_bulletproof(batch_amounts, C, masks));
+                    rv.p.bulletproofs.push_back(make_dummy_bulletproofXHV(batch_amounts, C, masks));
                 }
                 else
                 {
                     const epee::span<const key> keys{&amount_keys[amounts_proved], batch_size};
-                    rv.p.bulletproofs.push_back(proveRangeBulletproof(C, masks, batch_amounts, keys, hwdev));
-                #ifdef DBG
+                    rv.p.bulletproofs.push_back(proveRangeBulletproofXHV(C, masks, batch_amounts, keys, hwdev));
+		    //#ifdef DBG
                     CHECK_AND_ASSERT_THROW_MES(verBulletproof(rv.p.bulletproofs.back()), "verBulletproof failed on newly created proof");
-                #endif
+		    //#endif
                 }
                 for (i = 0; i < batch_size; ++i)
                 {
-                  rv.outPk[i + amounts_proved].mask = rct::scalarmult8(C[i]);
-                  outSk[i + amounts_proved].mask = masks[i];
+		  if ((outamounts[i + amounts_proved].first == 0) && (outamounts[i + amounts_proved].second != 0)) {
+                    rv.outPk[i + amounts_proved].mask = zeromask;
+                    rv.outPk_usd[i + amounts_proved].mask = rct::scalarmult8(C[i]);
+		  } else {
+                    rv.outPk[i + amounts_proved].mask = rct::scalarmult8(C[i]);
+                    rv.outPk_usd[i + amounts_proved].mask = zeromask;
+		  }
+		  outSk[i + amounts_proved].mask = masks[i];
                 }
                 amounts_proved += batch_size;
             }
         }
 
         key sumout = zero();
+	key atomic = d2h(1000000000000);
+	key rate = d2h(pr.unused1);
+	key inverse_atomic = invert(atomic);
+	key inverse_rate = invert(rate);
         for (i = 0; i < outSk.size(); ++i)
         {
-            sc_add(sumout.bytes, outSk[i].mask.bytes, sumout.bytes);
-
-            //mask amount and mask
-            rv.ecdhInfo[i].mask = copy(outSk[i].mask);
-            rv.ecdhInfo[i].amount = d2h(outamounts[i]);
-            hwdev.ecdhEncode(rv.ecdhInfo[i], amount_keys[i], rv.type == RCTTypeBulletproof2);
+	  key outSk_scaled = zero();
+	  key tempkey = zero();
+	  if (offshore || (!onshore && !offshore_to_offshore)) {
+	    // SPENDING XHV
+	    if ((outamounts[i].first == 0) && (outamounts[i].second != 0)) {
+	      // Convert output amount to XHV for equalKeys() testing
+	      sc_mul(tempkey.bytes, outSk[i].mask.bytes, atomic.bytes);
+	      sc_mul(outSk_scaled.bytes, tempkey.bytes, inverse_rate.bytes);
+	      //outSk_scaled = outSk[i].mask;
+	    } else {
+	      // Output amount in XHV already - no conversion required
+	      outSk_scaled = outSk[i].mask;
+	    }
+	  } else {
+	    // SPENDING USD
+	    if ((outamounts[i].first == 0) && (outamounts[i].second != 0)) {
+	      // Output amount in USD already - no conversion required
+	      outSk_scaled = outSk[i].mask;
+	    } else {
+	      // Convert output amount to USD for equalKeys() testing
+	      sc_mul(tempkey.bytes, outSk[i].mask.bytes, rate.bytes);
+	      sc_mul(outSk_scaled.bytes, tempkey.bytes, inverse_atomic.bytes);
+	      //outSk_scaled = outSk[i].mask;
+	    }
+	  }
+	  sc_add(sumout.bytes, outSk_scaled.bytes, sumout.bytes);
+	  
+	  //mask amount and mask
+	  uint64_t amount_nonzero = (outamounts[i].first == 0 ? outamounts[i].second : outamounts[i].first);
+	  rv.ecdhInfo[i].mask = copy(outSk[i].mask);
+	  rv.ecdhInfo[i].amount = d2h(amount_nonzero);
+	  hwdev.ecdhEncode(rv.ecdhInfo[i], amount_keys[i], rv.type == RCTTypeBulletproof2 || rv.type == RCTTypeCLSAG);
         }
             
         //set txn fee
         rv.txnFee = txnFee;
+        rv.txnFee_usd = txnFee_usd;
+        rv.txnOffshoreFee = txnOffshoreFee;
+        rv.txnOffshoreFee_usd = txnOffshoreFee_usd;
 //        TODO: unused ??
 //        key txnFeeKey = scalarmultH(d2h(rv.txnFee));
         rv.mixRing = mixRing;
         keyV &pseudoOuts = bulletproof ? rv.p.pseudoOuts : rv.pseudoOuts;
         pseudoOuts.resize(inamounts.size());
-        rv.p.MGs.resize(inamounts.size());
+        if (rv.type == RCTTypeCLSAG)
+            rv.p.CLSAGs.resize(inamounts.size());
+        else
+            rv.p.MGs.resize(inamounts.size());
         key sumpouts = zero(); //sum pseudoOut masks
         keyV a(inamounts.size());
+	std::vector<uint64_t> inamounts_nonzero = (inamounts[0].first != 0) ? inamounts_xhv : inamounts_usd;
         for (i = 0 ; i < inamounts.size() - 1; i++) {
-            skGen(a[i]);
-            sc_add(sumpouts.bytes, a[i].bytes, sumpouts.bytes);
-            genC(pseudoOuts[i], a[i], inamounts[i]);
+	  // Generate a random key
+	  skGen(a[i]);
+	  // Sum the random keys as we iterate
+	  sc_add(sumpouts.bytes, a[i].bytes, sumpouts.bytes);
+	  // Generate a commitment to the amount with the random key
+	  genC(pseudoOuts[i], a[i], inamounts_nonzero[i]);
         }
         sc_sub(a[i].bytes, sumout.bytes, sumpouts.bytes);
-        genC(pseudoOuts[i], a[i], inamounts[i]);
+        genC(pseudoOuts[i], a[i], inamounts_nonzero[i]);
         DP(pseudoOuts[i]);
 
         key full_message = get_pre_mlsag_hash(rv,hwdev);
         if (msout)
-          msout->c.resize(inamounts.size());
-        for (i = 0 ; i < inamounts.size(); i++) {
-            rv.p.MGs[i] = proveRctMGSimple(full_message, rv.mixRing[i], inSk[i], a[i], pseudoOuts[i], kLRki ? &(*kLRki)[i]: NULL, msout ? &msout->c[i] : NULL, index[i], hwdev);
+        {
+            msout->c.resize(inamounts.size());
+            msout->mu_p.resize(rv.type == RCTTypeCLSAG ? inamounts.size() : 0);
+        }
+        for (i = 0 ; i < inamounts.size(); i++)
+        {
+            if (rv.type == RCTTypeCLSAG)
+            {
+	      rv.p.CLSAGs[i] = proveRctCLSAGSimple(full_message, rv.mixRing[i], (xhv_sent ? inSk_xhv[i] : inSk_usd[i]), a[i], pseudoOuts[i], kLRki ? &(*kLRki)[i]: NULL, msout ? &msout->c[i] : NULL, msout ? &msout->mu_p[i] : NULL, index[i], hwdev);
+	      if (hwdev.get_mode() != hw::device::TRANSACTION_CREATE_FAKE) {
+		bool result_ver = verRctCLSAGSimple(full_message, rv.p.CLSAGs[i], rv.mixRing[i], pseudoOuts[i]);
+		CHECK_AND_ASSERT_THROW_MES(result_ver, "Sanity check on proveRctCLSAGSimple() failed");
+	      }
+	    }
+            else
+            {
+                rv.p.MGs[i] = proveRctMGSimple(full_message, rv.mixRing[i], inSk_xhv[i], a[i], pseudoOuts[i], kLRki ? &(*kLRki)[i]: NULL, msout ? &msout->c[i] : NULL, index[i], hwdev);
+            }
         }
         return rv;
     }
 
-    rctSig genRctSimple(const key &message, const ctkeyV & inSk, const ctkeyV & inPk, const keyV & destinations, const vector<xmr_amount> &inamounts, const vector<xmr_amount> &outamounts, const keyV &amount_keys, const std::vector<multisig_kLRki> *kLRki, multisig_out *msout, xmr_amount txnFee, unsigned int mixin, const RCTConfig &rct_config, hw::device &hwdev) {
+  rctSig genRctSimple(const key &message, const ctkeyM & inSk, const ctkeyV & inPk, const keyV & destinations, const vector<pair<xmr_amount,xmr_amount>> &inamounts, const vector<pair<xmr_amount,xmr_amount>> &outamounts, const keyV &amount_keys, const std::vector<multisig_kLRki> *kLRki, multisig_out *msout, xmr_amount txnFee, xmr_amount txnFee_usd, xmr_amount txnOffshoreFee, xmr_amount txnOffshoreFee_usd, unsigned int mixin, const RCTConfig &rct_config, hw::device &hwdev, const offshore::pricing_record pr) {
         std::vector<unsigned int> index;
         index.resize(inPk.size());
         ctkeyM mixRing;
@@ -905,7 +1528,7 @@
           mixRing[i].resize(mixin+1);
           index[i] = populateFromBlockchainSimple(mixRing[i], inPk[i], mixin);
         }
-        return genRctSimple(message, inSk, destinations, inamounts, outamounts, txnFee, mixRing, amount_keys, kLRki, msout, index, outSk, rct_config, hwdev);
+        return genRctSimple(message, inSk, destinations, inamounts, outamounts, txnFee, txnFee_usd, txnOffshoreFee, txnOffshoreFee_usd, mixRing, amount_keys, kLRki, msout, index, outSk, rct_config, hwdev, pr);
     }
 
     //RingCT protocol
@@ -978,9 +1601,18 @@
         }
     }
 
+    // yC = constant for USD/XHV exchange rate
+    // Ci = pseudoOuts[i] *** Ci & Di are MUTUALLY EXCLUSIVE
+    // fcG' = fee in XHV = 0
+    // C'k = outPk[k].mask
+    // yD = constant for XHV/USD exchange rate (1/yC)
+    // Di = pseudoOuts[i] *** Ci & Di are MUTUALLY EXCLUSIVE
+    // fdG' = fee in USD = 0
+    // D'k = outPk_usd[k].mask
+    //
     //ver RingCT simple
     //assumes only post-rct style inputs (at least for max anonymity)
-    bool verRctSemanticsSimple(const std::vector<const rctSig*> & rvv) {
+  bool verRctSemanticsSimple(const std::vector<const rctSig*> & rvv, const offshore::pricing_record pr, const bool offshore, const bool onshore, const bool offshore_to_offshore) {
       try
       {
         PERF_TIMER(verRctSemanticsSimple);
@@ -995,13 +1627,22 @@
         {
           CHECK_AND_ASSERT_MES(rvp, false, "rctSig pointer is NULL");
           const rctSig &rv = *rvp;
-          CHECK_AND_ASSERT_MES(rv.type == RCTTypeSimple || rv.type == RCTTypeBulletproof || rv.type == RCTTypeBulletproof2,
+          CHECK_AND_ASSERT_MES(rv.type == RCTTypeSimple || rv.type == RCTTypeBulletproof || rv.type == RCTTypeBulletproof2 || rv.type == RCTTypeCLSAG,
               false, "verRctSemanticsSimple called on non simple rctSig");
           const bool bulletproof = is_rct_bulletproof(rv.type);
           if (bulletproof)
           {
             CHECK_AND_ASSERT_MES(rv.outPk.size() == n_bulletproof_amounts(rv.p.bulletproofs), false, "Mismatched sizes of outPk and bulletproofs");
-            CHECK_AND_ASSERT_MES(rv.p.pseudoOuts.size() == rv.p.MGs.size(), false, "Mismatched sizes of rv.p.pseudoOuts and rv.p.MGs");
+            if (rv.type == RCTTypeCLSAG)
+            {
+              CHECK_AND_ASSERT_MES(rv.p.MGs.empty(), false, "MGs are not empty for CLSAG");
+              CHECK_AND_ASSERT_MES(rv.p.pseudoOuts.size() == rv.p.CLSAGs.size(), false, "Mismatched sizes of rv.p.pseudoOuts and rv.p.CLSAGs");
+            }
+            else
+            {
+              CHECK_AND_ASSERT_MES(rv.p.CLSAGs.empty(), false, "CLSAGs are not empty for MLSAG");
+              CHECK_AND_ASSERT_MES(rv.p.pseudoOuts.size() == rv.p.MGs.size(), false, "Mismatched sizes of rv.p.pseudoOuts and rv.p.MGs");
+            }
             CHECK_AND_ASSERT_MES(rv.pseudoOuts.empty(), false, "rv.pseudoOuts is not empty");
           }
           else
@@ -1024,21 +1665,79 @@
           const bool bulletproof = is_rct_bulletproof(rv.type);
           const keyV &pseudoOuts = bulletproof ? rv.p.pseudoOuts : rv.pseudoOuts;
 
-          rct::keyV masks(rv.outPk.size());
-          for (size_t i = 0; i < rv.outPk.size(); i++) {
-            masks[i] = rv.outPk[i].mask;
-          }
-          key sumOutpks = addKeys(masks);
-          DP(sumOutpks);
-          const key txnFeeKey = scalarmultH(d2h(rv.txnFee));
-          addKeys(sumOutpks, txnFeeKey, sumOutpks);
-
-          key sumPseudoOuts = addKeys(pseudoOuts);
-          DP(sumPseudoOuts);
-
-          //check pseudoOuts vs Outs..
-          if (!equalKeys(sumPseudoOuts, sumOutpks)) {
-            LOG_PRINT_L1("Sum check failed");
+	  // OUTPUTS SUMMED FOR EACH COLOUR
+	  key zerokey = scalarmultH(d2h(0));
+	  key Zi = zero();
+
+	  // Calculate sum of all C'
+	  rct::keyV masks(rv.outPk.size());
+	  for (size_t i = 0; i < rv.outPk.size(); i++) {
+	    masks[i] = rv.outPk[i].mask;
+	  }
+	  key sumOutpks = addKeys(masks);
+	  DP(sumOutpks);
+
+	  // Calculate sum of all D'
+	  rct::keyV masks_usd(rv.outPk_usd.size());
+	  for (size_t i = 0; i < rv.outPk_usd.size(); i++) {
+	    masks_usd[i] = rv.outPk_usd[i].mask;
+	  }
+	  key sumOutpks_usd = addKeys(masks_usd);
+	  DP(sumOutpks_usd);
+	  
+	  // FEES FOR EACH COLOUR
+	  
+	  // Calculate tx fee for C colour
+	  const key txnFeeKey = scalarmultH(d2h(rv.txnFee));
+
+	  // Calculate offshore conversion fee (also always in C colour)
+	  const key txnOffshoreFeeKey = scalarmultH(d2h(rv.txnOffshoreFee));
+
+	  // Calculate tx fee for D colour
+	  const key txnFeeKey_usd = scalarmultH(d2h(rv.txnFee_usd));
+
+	  // Calculate onshore conversion fee (also always in D colour)
+	  const key txnOffshoreFeeKey_usd = scalarmultH(d2h(rv.txnOffshoreFee_usd));
+
+	  key sumPseudoOuts = (offshore || (!onshore && !offshore_to_offshore)) ? addKeys(pseudoOuts) : zerokey;
+	  key sumPseudoOuts_usd = (offshore || (!onshore && !offshore_to_offshore)) ? zerokey : addKeys(pseudoOuts);
+	  DP(sumPseudoOuts);
+
+	  // C COLOUR
+	  key sumXHV;
+	  // Remove the fees
+	  subKeys(sumXHV, sumPseudoOuts, txnFeeKey);
+	  subKeys(sumXHV, sumXHV, txnOffshoreFeeKey);
+	  subKeys(sumXHV, sumXHV, sumOutpks);
+
+	  // D COLOUR
+	  key sumUSD;
+	  // Remove the fees
+	  subKeys(sumUSD, sumPseudoOuts_usd, txnFeeKey_usd);
+	  subKeys(sumUSD, sumUSD, txnOffshoreFeeKey_usd);
+	  subKeys(sumUSD, sumUSD, sumOutpks_usd);
+
+	  // NEAC: attempt to only calculate forward
+	  // CALCULATE Zi
+	  if (offshore) {
+	    key D_scaled = scalarmultKey(sumUSD, d2h(1000000000000));
+	    key yC_invert = invert(d2h(pr.unused1));
+	    key D_final = scalarmultKey(D_scaled, yC_invert);
+	    Zi = addKeys(sumXHV, D_final);
+	  } else if (onshore) {
+	    key C_scaled = scalarmultKey(sumXHV, d2h(pr.unused1));
+	    key yD_invert = invert(d2h(1000000000000));
+	    key C_final = scalarmultKey(C_scaled, yD_invert);
+	    Zi = addKeys(C_final, sumUSD);
+	  } else if (offshore_to_offshore) {
+	    Zi = addKeys(sumXHV, sumUSD);
+	  } else {
+	    Zi = addKeys(sumXHV, sumUSD);
+	  }
+	    
+          //check Zi == 0
+          if (!equalKeys(Zi, zerokey)) {
+            LOG_PRINT_L1("Sum check failed (Zi)");
             return false;
           }
 
@@ -1083,19 +1782,19 @@
       }
     }
 
-    bool verRctSemanticsSimple(const rctSig & rv)
+    bool verRctSemanticsSimple(const rctSig & rv, const offshore::pricing_record pr, const bool offshore, const bool onshore, const bool offshore_to_offshore)
     {
-      return verRctSemanticsSimple(std::vector<const rctSig*>(1, &rv));
+      return verRctSemanticsSimple(std::vector<const rctSig*>(1, &rv), pr, offshore, onshore, offshore_to_offshore);
     }
 
     //ver RingCT simple
     //assumes only post-rct style inputs (at least for max anonymity)
-    bool verRctNonSemanticsSimple(const rctSig & rv) {
+  bool verRctNonSemanticsSimple(const rctSig & rv) {
       try
       {
         PERF_TIMER(verRctNonSemanticsSimple);
 
-        CHECK_AND_ASSERT_MES(rv.type == RCTTypeSimple || rv.type == RCTTypeBulletproof || rv.type == RCTTypeBulletproof2,
+        CHECK_AND_ASSERT_MES(rv.type == RCTTypeSimple || rv.type == RCTTypeBulletproof || rv.type == RCTTypeBulletproof2 || rv.type == RCTTypeCLSAG,
             false, "verRctNonSemanticsSimple called on non simple rctSig");
         const bool bulletproof = is_rct_bulletproof(rv.type);
         // semantics check is early, and mixRing/MGs aren't resolved yet
@@ -1118,14 +1817,19 @@
         results.resize(rv.mixRing.size());
         for (size_t i = 0 ; i < rv.mixRing.size() ; i++) {
           tpool.submit(&waiter, [&, i] {
-              results[i] = verRctMGSimple(message, rv.p.MGs[i], rv.mixRing[i], pseudoOuts[i]);
+              if (rv.type == RCTTypeCLSAG)
+              {
+                  results[i] = verRctCLSAGSimple(message, rv.p.CLSAGs[i], rv.mixRing[i], pseudoOuts[i]);
+              }
+              else
+                  results[i] = verRctMGSimple(message, rv.p.MGs[i], rv.mixRing[i], pseudoOuts[i]);
           });
         }
         waiter.wait(&tpool);
 
         for (size_t i = 0; i < results.size(); ++i) {
           if (!results[i]) {
-            LOG_PRINT_L1("verRctMGSimple failed for input " << i);
+            LOG_PRINT_L1("verRctMGSimple/verRctCLSAGSimple failed for input " << i);
             return false;
           }
         }
@@ -1162,7 +1866,7 @@
 
         //mask amount and mask
         ecdhTuple ecdh_info = rv.ecdhInfo[i];
-        hwdev.ecdhDecode(ecdh_info, sk, rv.type == RCTTypeBulletproof2);
+        hwdev.ecdhDecode(ecdh_info, sk, rv.type == RCTTypeBulletproof2 || rv.type == RCTTypeCLSAG);
         mask = ecdh_info.mask;
         key amount = ecdh_info.amount;
         key C = rv.outPk[i].mask;
@@ -1186,16 +1890,16 @@
     }
 
     xmr_amount decodeRctSimple(const rctSig & rv, const key & sk, unsigned int i, key &mask, hw::device &hwdev) {
-        CHECK_AND_ASSERT_MES(rv.type == RCTTypeSimple || rv.type == RCTTypeBulletproof || rv.type == RCTTypeBulletproof2, false, "decodeRct called on non simple rctSig");
+        CHECK_AND_ASSERT_MES(rv.type == RCTTypeSimple || rv.type == RCTTypeBulletproof || rv.type == RCTTypeBulletproof2 || rv.type == RCTTypeCLSAG, false, "decodeRct called on non simple rctSig");
         CHECK_AND_ASSERT_THROW_MES(i < rv.ecdhInfo.size(), "Bad index");
         CHECK_AND_ASSERT_THROW_MES(rv.outPk.size() == rv.ecdhInfo.size(), "Mismatched sizes of rv.outPk and rv.ecdhInfo");
 
         //mask amount and mask
         ecdhTuple ecdh_info = rv.ecdhInfo[i];
-        hwdev.ecdhDecode(ecdh_info, sk, rv.type == RCTTypeBulletproof2);
+        hwdev.ecdhDecode(ecdh_info, sk, rv.type == RCTTypeBulletproof2 || rv.type == RCTTypeCLSAG);
         mask = ecdh_info.mask;
         key amount = ecdh_info.amount;
-        key C = rv.outPk[i].mask;
+        key C = (equalKeys(scalarmultH(d2h(0)),rv.outPk[i].mask)) ? rv.outPk_usd[i].mask : rv.outPk[i].mask;
         DP("C");
         DP(C);
         key Ctmp;
@@ -1215,12 +1919,13 @@
       return decodeRctSimple(rv, sk, i, mask, hwdev);
     }
 
-    bool signMultisig(rctSig &rv, const std::vector<unsigned int> &indices, const keyV &k, const multisig_out &msout, const key &secret_key) {
+    bool signMultisigMLSAG(rctSig &rv, const std::vector<unsigned int> &indices, const keyV &k, const multisig_out &msout, const key &secret_key) {
         CHECK_AND_ASSERT_MES(rv.type == RCTTypeFull || rv.type == RCTTypeSimple || rv.type == RCTTypeBulletproof || rv.type == RCTTypeBulletproof2,
             false, "unsupported rct type");
         CHECK_AND_ASSERT_MES(indices.size() == k.size(), false, "Mismatched k/indices sizes");
         CHECK_AND_ASSERT_MES(k.size() == rv.p.MGs.size(), false, "Mismatched k/MGs size");
         CHECK_AND_ASSERT_MES(k.size() == msout.c.size(), false, "Mismatched k/msout.c size");
+        CHECK_AND_ASSERT_MES(rv.p.CLSAGs.empty(), false, "CLSAGs not empty for MLSAGs");
         if (rv.type == RCTTypeFull)
         {
           CHECK_AND_ASSERT_MES(rv.p.MGs.size() == 1, false, "MGs not a single element");
@@ -1230,6 +1935,8 @@
             CHECK_AND_ASSERT_MES(!rv.p.MGs[n].ss[indices[n]].empty(), false, "empty ss line");
         }
 
+        // MLSAG: each player contributes a share to the secret-index ss: k - cc*secret_key_share
+        //     cc: msout.c[n], secret_key_share: secret_key
         for (size_t n = 0; n < indices.size(); ++n) {
             rct::key diff;
             sc_mulsub(diff.bytes, msout.c[n].bytes, secret_key.bytes, k[n].bytes);
@@ -1237,4 +1944,71 @@
         }
         return true;
     }
+
+    bool signMultisigCLSAG(rctSig &rv, const std::vector<unsigned int> &indices, const keyV &k, const multisig_out &msout, const key &secret_key) {
+        CHECK_AND_ASSERT_MES(rv.type == RCTTypeCLSAG, false, "unsupported rct type");
+        CHECK_AND_ASSERT_MES(indices.size() == k.size(), false, "Mismatched k/indices sizes");
+        CHECK_AND_ASSERT_MES(k.size() == rv.p.CLSAGs.size(), false, "Mismatched k/MGs size");
+        CHECK_AND_ASSERT_MES(k.size() == msout.c.size(), false, "Mismatched k/msout.c size");
+        CHECK_AND_ASSERT_MES(rv.p.MGs.empty(), false, "MGs not empty for CLSAGs");
+        CHECK_AND_ASSERT_MES(msout.c.size() == msout.mu_p.size(), false, "Bad mu_p size");
+        for (size_t n = 0; n < indices.size(); ++n) {
+            CHECK_AND_ASSERT_MES(indices[n] < rv.p.CLSAGs[n].s.size(), false, "Index out of range");
+        }
+
+        // CLSAG: each player contributes a share to the secret-index ss: k - cc*mu_p*secret_key_share
+        // cc: msout.c[n], mu_p, msout.mu_p[n], secret_key_share: secret_key
+        for (size_t n = 0; n < indices.size(); ++n) {
+            rct::key diff, sk;
+            sc_mul(sk.bytes, msout.mu_p[n].bytes, secret_key.bytes);
+            sc_mulsub(diff.bytes, msout.c[n].bytes, sk.bytes, k[n].bytes);
+            sc_add(rv.p.CLSAGs[n].s[indices[n]].bytes, rv.p.CLSAGs[n].s[indices[n]].bytes, diff.bytes);
+        }
+        return true;
+    }
+
+    bool signMultisig(rctSig &rv, const std::vector<unsigned int> &indices, const keyV &k, const multisig_out &msout, const key &secret_key) {
+        if (rv.type == RCTTypeCLSAG)
+            return signMultisigCLSAG(rv, indices, k, msout, secret_key);
+        else
+            return signMultisigMLSAG(rv, indices, k, msout, secret_key);
+    }
+
+  bool checkBurntAndMinted(const rctSig &rv, const xmr_amount amount_burnt, const xmr_amount amount_minted, const offshore::pricing_record pr, bool offshore, bool onshore) {
+
+    if (offshore) {
+
+      boost::multiprecision::uint128_t xhv_128 = amount_burnt;
+      boost::multiprecision::uint128_t exchange_128 = pr.unused1;
+      boost::multiprecision::uint128_t xusd_128 = xhv_128 * exchange_128;
+      xusd_128 /= 1000000000000;
+      boost::multiprecision::uint128_t minted_128 = amount_minted;
+      if (xusd_128 != minted_128) {
+
+	LOG_PRINT_L1("Sum check failed (offshore)");
+	return false;
+      }
+      
+    } else if (onshore) {
+
+      boost::multiprecision::uint128_t xusd_128 = amount_burnt;
+      boost::multiprecision::uint128_t exchange_128 = pr.unused1;
+      boost::multiprecision::uint128_t xhv_128 = xusd_128 * 1000000000000;
+      xhv_128 /= exchange_128;
+      boost::multiprecision::uint128_t minted_128 = amount_minted;
+      if ((uint64_t)xhv_128 != minted_128) {
+
+	LOG_PRINT_L1("Sum check failed (onshore)");
+	return false;
+      }
+
+    } else {
+
+      LOG_PRINT_L1("Invalid request - minted/burnt values only valid for offshore/onshore TXs");
+      return false;
+    }
+
+    // Must have succeeded
+    return true;
+  }
 }
