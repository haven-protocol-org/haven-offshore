diff --git a/src/cryptonote_core/tx_pool.cpp b/src/cryptonote_core/tx_pool.cpp
index 696bc88d4..66ef307a9 100644
--- a/src/cryptonote_core/tx_pool.cpp
+++ b/src/cryptonote_core/tx_pool.cpp
@@ -47,6 +47,7 @@
 #include "common/perf_timer.h"
 #include "crypto/hash.h"
 #include "crypto/duration.h"
+#include "offshore/asset_types.h"
 
 #undef MONERO_DEFAULT_LOG_CATEGORY
 #define MONERO_DEFAULT_LOG_CATEGORY "txpool"
@@ -107,8 +108,8 @@ namespace cryptonote
 
     uint64_t get_transaction_weight_limit(uint8_t version)
     {
-      // from v8, limit a tx to 50% of the minimum block weight
-      if (version >= 8)
+      // from v5, limit a tx to 50% of the minimum block weight
+      if (version >= 5)
         return get_min_block_weight(version) / 2 - CRYPTONOTE_COINBASE_BLOB_RESERVED_SIZE;
       else
         return get_min_block_weight(version) - CRYPTONOTE_COINBASE_BLOB_RESERVED_SIZE;
@@ -155,7 +156,7 @@ namespace cryptonote
     }
 
     // fee per kilobyte, size rounded up.
-    uint64_t fee;
+    uint64_t fee = 0, fee_usd = 0, fee_xasset = 0, offshore_fee = 0, offshore_fee_usd = 0, offshore_fee_xasset = 0;
 
     if (tx.version == 1)
     {
@@ -166,7 +167,7 @@ namespace cryptonote
         return false;
       }
 
-      uint64_t outputs_amount = get_outs_money_amount(tx);
+      uint64_t outputs_amount = get_outs_money_amount(tx)["XHV"];
       if(outputs_amount > inputs_amount)
       {
         LOG_PRINT_L1("transaction use more money than it has: use " << print_money(outputs_amount) << ", have " << print_money(inputs_amount));
@@ -187,15 +188,233 @@ namespace cryptonote
     else
     {
       fee = tx.rct_signatures.txnFee;
+      fee_usd = tx.rct_signatures.txnFee_usd;
+      fee_xasset = tx.rct_signatures.txnFee_xasset;
+      offshore_fee = tx.rct_signatures.txnOffshoreFee;
+      offshore_fee_usd = tx.rct_signatures.txnOffshoreFee_usd;
+      offshore_fee_xasset = tx.rct_signatures.txnOffshoreFee_xasset;
     }
 
-    if (!kept_by_block && !m_blockchain.check_fee(tx_weight, fee))
-    {
+    //validate the offshore data
+    bool bOffshoreTx = false;
+    tx_extra_offshore offshore_data;
+    if (tx.extra.size()) {
+      bOffshoreTx = get_offshore_from_tx_extra(tx.extra, offshore_data);
+    }
+    if (bOffshoreTx) {
+      if (version >= HF_VERSION_XASSET_FULL) {
+        int pos = offshore_data.data.find("-");
+        if (pos != std::string::npos) {
+          std::string source = offshore_data.data.substr(0,pos);
+          std::string dest = offshore_data.data.substr(pos+1);
+          // check both strSource and strDest are supported.
+          if (std::find(offshore::ASSET_TYPES.begin(), offshore::ASSET_TYPES.end(), source) == offshore::ASSET_TYPES.end()) {
+            tvc.m_verifivation_failed = true;
+            LOG_PRINT_L1("Source Asset type " << source << " is not supported! Rejecting..");
+            return false;
+          }
+          if (std::find(offshore::ASSET_TYPES.begin(), offshore::ASSET_TYPES.end(), dest) == offshore::ASSET_TYPES.end()) {
+            tvc.m_verifivation_failed = true;
+            LOG_PRINT_L1("Destination Asset type " << dest << " is not supported! Rejecting..");
+            return false;
+          }
+        } else {
+          LOG_PRINT_L1("Invalid offshore data format was supplied to tx." << id);
+          tvc.m_verifivation_failed = true;
+          return false;
+        }
+      } else if (version >= HF_VERSION_OFFSHORE_FULL) {
+        if (offshore_data.data.size() != 2 ||
+          (offshore_data.data.at(0) != 'A' && offshore_data.data.at(0) != 'N') || 
+          (offshore_data.data.at(1) != 'A' && offshore_data.data.at(1) != 'N')
+        ){
+          // old offshore data format suplied to tx extra
+          LOG_PRINT_L1("Invalid offshore data format was supplied to tx." << id);
+          tvc.m_verifivation_failed = true;
+          return false;
+        }
+      }
+
+      std::string tx_offshore_data(tx.offshore_data.begin(), tx.offshore_data.end());
+      if(tx_offshore_data.empty()) {
+        if (version >= HF_VERSION_XASSET_FULL) {
+          // old offshore data format suplied to tx extra
+          LOG_PRINT_L1("Empty tx_offshore_data." << id);
+          tvc.m_verifivation_failed = true;
+          return false;
+        } else if (version >= HF_VERSION_OFFSHORE_FULL) {
+          // offshore_data must be "NN"
+          if (offshore_data.data != "NN") {
+            // old offshore data format suplied to tx extra
+            LOG_PRINT_L1("Invalid offshore data format was supplied to tx." << id);
+            tvc.m_verifivation_failed = true;
+            return false;
+          }
+        }
+      } else {
+        if (tx_offshore_data != offshore_data.data) {
+          // old offshore data format suplied to tx extra
+          LOG_PRINT_L1("Tx offshore data doesn't match with the one from tx extra." << id);
+          tvc.m_verifivation_failed = true;
+          return false;
+        }
+      }
+    }
+
+    // Check to make sure that only 1 destination is provided if memo data is specified.
+    // This is necessary because we shuffle outputs and there is no way to identify which memo data would relate to which destination if multiples were permitted.
+    tx_extra_memo memo;
+    if (get_memo_from_tx_extra(tx.extra, memo)) {
+      if (tx.vout.size() > 2) {
+        LOG_PRINT_L1("transaction has memo data and multiple destinations specified - this is not permitted, rejecting.");
+        tvc.m_verifivation_failed = true;
+        return false;
+      }
+    }
+
+    // Set the offshore TX type flags
+    bool offshore = false;
+    bool onshore = false;
+    bool offshore_transfer = false;
+    bool xasset_transfer = false;
+    bool xasset_to_xusd = false;
+    bool xusd_to_xasset = false;
+    std::string source;
+    std::string dest;
+    offshore::pricing_record pr;
+    if (!get_tx_asset_types(tx, source, dest)) {
+      LOG_PRINT_L1("At least 1 input or 1 output of the tx was invalid." << id);
       tvc.m_verifivation_failed = true;
-      tvc.m_fee_too_low = true;
+      if (source.empty()) {
+        tvc.m_invalid_input = true;
+      }
+      if (dest.empty()) {
+        tvc.m_invalid_output = true;
+      }
       return false;
     }
+    if (!get_tx_type(source, dest, offshore, onshore, offshore_transfer, xusd_to_xasset, xasset_to_xusd, xasset_transfer)) {
+      LOG_ERROR("At least 1 input or 1 output of the tx was invalid." << tx.hash);
+      tvc.m_verifivation_failed = true;
+      return false;
+    }
+
+    if (offshore || onshore || xusd_to_xasset || xasset_to_xusd) {
+
+      // Validate that pricing record is not too old
+      uint64_t current_height = m_blockchain.get_current_blockchain_height();
+      if ((current_height - PRICING_RECORD_VALID_BLOCKS) > tx.pricing_record_height) {
+
+        // For a time, pricing record validation on tx's existed only in 2 places: here when first adding a tx into the pool, and the less important tx_sanity_check.
+        // At some point before block 848280, the transaction with hash 3e61439c9f751a56777a1df1479ce70311755b9d42db5bcbbd873c6f09a020a6 entered the tx pool
+        // successfully, and then sat in the pool until being mined in block 848280, at which point the tx's pricing record had grown too old and should have
+        // been validated again, but was not. Live nodes that remained connected to the network continued building off the chain, since this tx had already 
+        // passed validation to enter their tx pool in the first place, thereby preventing other nodes disconnected from the network from adding this tx later on. 
+        // This issue was prevented by adding pricing record validation in handle_block_to_main_chain (blockchain.cpp), so that connected nodes would reject a 
+        // pricing record if it has grown too old since first entering the pool. Unfortunately a single tx was affected by this issue, which was tx 
+        // 3e61439c9f751a56777a1df1479ce70311755b9d42db5bcbbd873c6f09a020a6 below. Nodes will allow this tx and only this tx to pass validation.
+        if (current_height != 848280 || tx.pricing_record_height != 848269 || epee::string_tools::pod_to_hex(tx.hash) != "3e61439c9f751a56777a1df1479ce70311755b9d42db5bcbbd873c6f09a020a6")
+        {
+          LOG_PRINT_L2("error : offshore/xAsset transaction references a pricing record that is too old (height " << tx.pricing_record_height << ")");
+          tvc.m_verifivation_failed = true;
+          return false;
+        }
+      }
+      
+      // this check is here because of a soft fork that needed to happen due to invalid pr
+      if (tx.pricing_record_height > 658500) {
+
+        // NEAC: recover from the reorg during Oracle switch - 1 TX affected
+        if (tx.pricing_record_height == 821428) {
+          const std::string pr_821428 = "9b3f6f2f8f0000003d620e1202000000be71be2555120000b8627010000000000000000000000000ea0885b2270d00000000000000000000f797ff9be00b0000ddbdb005270a0000fc90cfe02b01060000000000000000000000000000000000d0a28224000e000000d643be960e0000002e8bb6a40e000000f8a817f80d00002f5d27d45cdbfbac3d0f6577103f68de30895967d7562fbd56c161ae90130f54301b1ea9d5fd062f37dac75c3d47178bc6f149d21da1ff0e8430065cb762b93a";
+          pr.xAG = 614976143259;
+          pr.xAU = 8892867133;
+          pr.xAUD = 20156914758078;
+          pr.xBTC = 275800760;
+          pr.xCAD = 0;
+          pr.xCHF = 14464149948650;
+          pr.xCNY = 0;
+          pr.xEUR = 13059317798903;
+          pr.xGBP = 11162715471325;
+          pr.xJPY = 1690137827184892;
+          pr.xNOK = 0;
+          pr.xNZD = 0;
+          pr.xUSD = 15393775330000;
+          pr.unused1 = 16040600000000;
+          pr.unused2 = 16100600000000;
+          pr.unused3 = 15359200000000;
+          std::string sig = "2f5d27d45cdbfbac3d0f6577103f68de30895967d7562fbd56c161ae90130f54301b1ea9d5fd062f37dac75c3d47178bc6f149d21da1ff0e8430065cb762b93a";
+          int j=0;
+          for (unsigned int i = 0; i < sig.size(); i += 2) {
+            std::string byteString = sig.substr(i, 2);
+            pr.signature[j++] = (char) strtol(byteString.c_str(), NULL, 16);
+          }
+        } else {
+          // Get the pricing record that was used for conversion
+          block bl;
+          bool r = m_blockchain.get_block_by_hash(m_blockchain.get_block_id_by_height(tx.pricing_record_height), bl);
+          if (!r) {
+            LOG_ERROR("error: failed to get block containing pricing record");
+            tvc.m_verifivation_failed = true;
+            return false;
+          }
+
+          pr = bl.pricing_record;
+        }
+        ////// recover ends //////////
 
+        // verify the pr
+        if (!pr.verifySignature()) {
+          LOG_ERROR("Failed to set correct PR for block: " << tx.pricing_record_height);
+          return false;
+        }
+
+        // Check the amount burnt and minted
+        if (!rct::checkBurntAndMinted(tx.rct_signatures, tx.amount_burnt, tx.amount_minted, pr, source, dest)) {
+          LOG_PRINT_L1("amount burnt / minted is incorrect: burnt = " << tx.amount_burnt << ", minted = " << tx.amount_minted);
+          tvc.m_verifivation_failed = true;
+          return false;
+        }
+
+        // Verify the offshore conversion fee is present and correct here
+        uint64_t unlock_time = tx.unlock_time - tx.pricing_record_height;
+        if (offshore || onshore) {
+          if (unlock_time < 180) {
+            LOG_PRINT_L1("unlock_time is too short: " << unlock_time << " blocks - rejecting (minimum permitted is 180 blocks)");
+            tvc.m_verifivation_failed = true;
+            return false;
+          }
+        }
+        uint64_t priority = (unlock_time >= 5040) ? 1 : (unlock_time >= 1440) ? 2 : (unlock_time >= 720) ? 3 : 4;
+        uint64_t conversion_fee_check = 0;
+        if (offshore || onshore) {
+          conversion_fee_check = (priority == 1) ? tx.amount_burnt / 500 : (priority == 2) ? tx.amount_burnt / 20 : (priority == 3) ? tx.amount_burnt / 10 : tx.amount_burnt / 5;
+        } else if (xusd_to_xasset || xasset_to_xusd) {
+          // Flat 0.3% conversion fee for xAsset TXs
+          conversion_fee_check = (tx.amount_burnt * 3) / 1000;
+        }
+        if (
+          (offshore && (conversion_fee_check != tx.rct_signatures.txnOffshoreFee)) ||
+          ((onshore || xusd_to_xasset) && (conversion_fee_check != tx.rct_signatures.txnOffshoreFee_usd)) ||
+	        (xasset_to_xusd && (conversion_fee_check != tx.rct_signatures.txnOffshoreFee_xasset))
+        ){
+          LOG_PRINT_L1("conversion fee is incorrect - rejecting");
+          tvc.m_verifivation_failed = true;
+          tvc.m_fee_too_low = true;
+          return false;
+        }
+      }
+    }
+
+    // check the std tx fee
+    if (!kept_by_block) {
+      if ((!fee && !fee_usd && !fee_xasset) || !m_blockchain.check_fee(tx_weight, source == "XHV" ? fee : source == "XUSD" ? fee_usd : fee_xasset, pr, source, dest)){
+        tvc.m_verifivation_failed = true;
+        tvc.m_fee_too_low = true;
+        return false;
+      }
+    }
+    
     size_t tx_weight_limit = get_transaction_weight_limit(version);
     if ((!kept_by_block || version >= HF_VERSION_PER_BYTE_FEE) && tx_weight > tx_weight_limit)
     {
@@ -236,6 +455,7 @@ namespace cryptonote
     crypto::hash max_used_block_id = null_hash;
     uint64_t max_used_block_height = 0;
     cryptonote::txpool_tx_meta_t meta{};
+    strcpy(meta.fee_asset_type, source.c_str());
     bool ch_inp_res = check_tx_inputs([&tx]()->cryptonote::transaction&{ return tx; }, id, max_used_block_height, max_used_block_id, tvc, kept_by_block);
     if(!ch_inp_res)
     {
@@ -244,7 +464,16 @@ namespace cryptonote
       if(kept_by_block)
       {
         meta.weight = tx_weight;
-        meta.fee = fee;
+        if (source == "XHV") {
+          meta.fee = fee;
+          meta.offshore_fee = offshore_fee;
+        } else if (source == "XUSD") {
+          meta.fee = fee_usd;
+          meta.offshore_fee = offshore_fee_usd;
+        } else {
+          meta.fee = fee_xasset;
+          meta.offshore_fee = offshore_fee_xasset;
+        }
         meta.max_used_block_id = null_hash;
         meta.max_used_block_height = 0;
         meta.last_failed_height = 0;
@@ -256,6 +485,7 @@ namespace cryptonote
         meta.double_spend_seen = have_tx_keyimges_as_spent(tx, id);
         meta.pruned = tx.pruned;
         meta.bf_padding = 0;
+        memset(meta.padding1, 0, sizeof(meta.padding1));
         memset(meta.padding, 0, sizeof(meta.padding));
         try
         {
@@ -267,7 +497,7 @@ namespace cryptonote
             return false;
 
           m_blockchain.add_txpool_tx(id, blob, meta);
-          m_txs_by_fee_and_receive_time.emplace(std::pair<double, std::time_t>(fee / (double)(tx_weight ? tx_weight : 1), receive_time), id);
+          m_txs_by_fee_and_receive_time.emplace(std::pair<double, std::time_t>(meta.fee / (double)(tx_weight ? tx_weight : 1), receive_time), id);
           lock.commit();
         }
         catch (const std::exception &e)
@@ -313,7 +543,16 @@ namespace cryptonote
           meta.last_relayed_time = std::numeric_limits<decltype(meta.last_relayed_time)>::max();
           meta.receive_time = receive_time;
           meta.weight = tx_weight;
-          meta.fee = fee;
+          if (source == "XHV") {
+            meta.fee = fee;
+            meta.offshore_fee = offshore_fee;
+          } else if (source == "XUSD") {
+            meta.fee = fee_usd;
+            meta.offshore_fee = offshore_fee_usd;
+          } else {
+            meta.fee = fee_xasset;
+            meta.offshore_fee = offshore_fee_xasset;
+          }
           meta.max_used_block_id = max_used_block_id;
           meta.max_used_block_height = max_used_block_height;
           meta.last_failed_height = 0;
@@ -322,6 +561,7 @@ namespace cryptonote
           meta.double_spend_seen = false;
           meta.pruned = tx.pruned;
           meta.bf_padding = 0;
+	  memset(meta.padding1, 0, sizeof(meta.padding1));
           memset(meta.padding, 0, sizeof(meta.padding));
 
           if (!insert_key_images(tx, id, tx_relay))
@@ -329,7 +569,7 @@ namespace cryptonote
 
           m_blockchain.remove_txpool_tx(id);
           m_blockchain.add_txpool_tx(id, blob, meta);
-          m_txs_by_fee_and_receive_time.emplace(std::pair<double, std::time_t>(fee / (double)(tx_weight ? tx_weight : 1), receive_time), id);
+          m_txs_by_fee_and_receive_time.emplace(std::pair<double, std::time_t>(meta.fee / (double)(tx_weight ? tx_weight : 1), receive_time), id);
         }
         lock.commit();
       }
@@ -341,8 +581,9 @@ namespace cryptonote
       tvc.m_added_to_pool = true;
 
       static_assert(unsigned(relay_method::none) == 0, "expected relay_method::none value to be zero");
-      if(meta.fee > 0)
+      if(meta.fee > 0){
         tvc.m_relay = tx_relay;
+      }
     }
 
     tvc.m_verifivation_failed = false;
@@ -350,7 +591,7 @@ namespace cryptonote
 
     ++m_cookie;
 
-    MINFO("Transaction added to pool: txid " << id << " weight: " << tx_weight << " fee/byte: " << (fee / (double)(tx_weight ? tx_weight : 1)));
+    MINFO("Transaction added to pool: txid " << id << " weight: " << tx_weight << " fee/byte: " << (meta.fee / (double)(tx_weight ? tx_weight : 1)) << " " << source);
 
     prune(m_txpool_max_weight);
 
@@ -441,28 +682,88 @@ namespace cryptonote
   //---------------------------------------------------------------------------------
   bool tx_memory_pool::insert_key_images(const transaction_prefix &tx, const crypto::hash &id, relay_method tx_relay)
   {
-    for(const auto& in: tx.vin)
-    {
-      CHECKED_GET_SPECIFIC_VARIANT(in, const txin_to_key, txin, false);
-      std::unordered_set<crypto::hash>& kei_image_set = m_spent_key_images[txin.k_image];
+    
+    if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(const auto& in: tx.vin)
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(in, const txin_offshore, txin, false);
+        std::unordered_set<crypto::hash>& kei_image_set = m_spent_key_images[txin.k_image];
+        if (tx_relay != relay_method::block)
+        {
+          const bool one_txid =
+            (kei_image_set.empty() || (kei_image_set.size() == 1 && *(kei_image_set.cbegin()) == id));
+          CHECK_AND_ASSERT_MES(one_txid, false, "internal error: tx_relay=" << unsigned(tx_relay)
+                                            << ", kei_image_set.size()=" << kei_image_set.size() << ENDL << "txin.k_image=" << txin.k_image << ENDL
+                                            << "tx_id=" << id);
+        }
 
-      // Only allow multiple txes per key-image if kept-by-block. Only allow
-      // the same txid if going from local/stem->fluff.
+      const bool new_or_previously_private =
+        kei_image_set.insert(id).second ||
+        !m_blockchain.txpool_tx_matches_category(id, relay_category::legacy);
+      CHECK_AND_ASSERT_MES(new_or_previously_private, false, "internal error: try to insert duplicate iterator in key_image set");
+      }
+    }
+    else if (tx.vin[0].type() == typeid(txin_onshore)) {
+      for(const auto& in: tx.vin)
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(in, const txin_onshore, txin, false);
+        std::unordered_set<crypto::hash>& kei_image_set = m_spent_key_images[txin.k_image];
+        if (tx_relay != relay_method::block)
+        {
+          const bool one_txid =
+            (kei_image_set.empty() || (kei_image_set.size() == 1 && *(kei_image_set.cbegin()) == id));
+          CHECK_AND_ASSERT_MES(one_txid, false, "internal error: tx_relay=" << unsigned(tx_relay)
+                                            << ", kei_image_set.size()=" << kei_image_set.size() << ENDL << "txin.k_image=" << txin.k_image << ENDL
+                                            << "tx_id=" << id);
+        }
 
-      if (tx_relay != relay_method::block)
+      const bool new_or_previously_private =
+        kei_image_set.insert(id).second ||
+        !m_blockchain.txpool_tx_matches_category(id, relay_category::legacy);
+      CHECK_AND_ASSERT_MES(new_or_previously_private, false, "internal error: try to insert duplicate iterator in key_image set");
+      }
+    }
+    else if (tx.vin[0].type() == typeid(txin_xasset)) {
+      for(const auto& in: tx.vin)
       {
-        const bool one_txid =
-          (kei_image_set.empty() || (kei_image_set.size() == 1 && *(kei_image_set.cbegin()) == id));
-        CHECK_AND_ASSERT_MES(one_txid, false, "internal error: tx_relay=" << unsigned(tx_relay)
-                                           << ", kei_image_set.size()=" << kei_image_set.size() << ENDL << "txin.k_image=" << txin.k_image << ENDL
-                                           << "tx_id=" << id);
+        CHECKED_GET_SPECIFIC_VARIANT(in, const txin_xasset, txin, false);
+        std::unordered_set<crypto::hash>& kei_image_set = m_spent_key_images[txin.k_image];
+        if (tx_relay != relay_method::block)
+        {
+          const bool one_txid =
+            (kei_image_set.empty() || (kei_image_set.size() == 1 && *(kei_image_set.cbegin()) == id));
+          CHECK_AND_ASSERT_MES(one_txid, false, "internal error: tx_relay=" << unsigned(tx_relay)
+                                            << ", kei_image_set.size()=" << kei_image_set.size() << ENDL << "txin.k_image=" << txin.k_image << ENDL
+                                            << "tx_id=" << id);
+        }
+
+      const bool new_or_previously_private =
+        kei_image_set.insert(id).second ||
+        !m_blockchain.txpool_tx_matches_category(id, relay_category::legacy);
+      CHECK_AND_ASSERT_MES(new_or_previously_private, false, "internal error: try to insert duplicate iterator in key_image set");
       }
+    }
+    else if (tx.vin[0].type() == typeid(txin_to_key)) {
+      for(const auto& in: tx.vin)
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(in, const txin_to_key, txin, false);
+        std::unordered_set<crypto::hash>& kei_image_set = m_spent_key_images[txin.k_image];
+        if (tx_relay != relay_method::block)
+        {
+          const bool one_txid =
+            (kei_image_set.empty() || (kei_image_set.size() == 1 && *(kei_image_set.cbegin()) == id));
+          CHECK_AND_ASSERT_MES(one_txid, false, "internal error: tx_relay=" << unsigned(tx_relay)
+                                            << ", kei_image_set.size()=" << kei_image_set.size() << ENDL << "txin.k_image=" << txin.k_image << ENDL
+                                            << "tx_id=" << id);
+        }
 
       const bool new_or_previously_private =
         kei_image_set.insert(id).second ||
         !m_blockchain.txpool_tx_matches_category(id, relay_category::legacy);
       CHECK_AND_ASSERT_MES(new_or_previously_private, false, "internal error: try to insert duplicate iterator in key_image set");
+      }
     }
+    
     ++m_cookie;
     return true;
   }
@@ -475,32 +776,99 @@ namespace cryptonote
     CRITICAL_REGION_LOCAL(m_transactions_lock);
     CRITICAL_REGION_LOCAL1(m_blockchain);
     // ND: Speedup
-    for(const txin_v& vi: tx.vin)
-    {
-      CHECKED_GET_SPECIFIC_VARIANT(vi, const txin_to_key, txin, false);
-      auto it = m_spent_key_images.find(txin.k_image);
-      CHECK_AND_ASSERT_MES(it != m_spent_key_images.end(), false, "failed to find transaction input in key images. img=" << txin.k_image << ENDL
-                                    << "transaction id = " << actual_hash);
-      std::unordered_set<crypto::hash>& key_image_set =  it->second;
-      CHECK_AND_ASSERT_MES(key_image_set.size(), false, "empty key_image set, img=" << txin.k_image << ENDL
-        << "transaction id = " << actual_hash);
-
-      auto it_in_set = key_image_set.find(actual_hash);
-      CHECK_AND_ASSERT_MES(it_in_set != key_image_set.end(), false, "transaction id not found in key_image set, img=" << txin.k_image << ENDL
-        << "transaction id = " << actual_hash);
-      key_image_set.erase(it_in_set);
-      if(!key_image_set.size())
+    if (tx.vin[0].type() == typeid(txin_onshore)) {
+      for(const txin_v& vi: tx.vin)
       {
-        //it is now empty hash container for this key_image
-        m_spent_key_images.erase(it);
+        CHECKED_GET_SPECIFIC_VARIANT(vi, const txin_onshore, txin, false);
+        auto it = m_spent_key_images.find(txin.k_image);
+        CHECK_AND_ASSERT_MES(it != m_spent_key_images.end(), false, "failed to find transaction input in key images. img=" << txin.k_image << ENDL
+                << "transaction id = " << actual_hash);
+        std::unordered_set<crypto::hash>& key_image_set =  it->second;
+        CHECK_AND_ASSERT_MES(key_image_set.size(), false, "empty key_image set, img=" << txin.k_image << ENDL
+                << "transaction id = " << actual_hash);
+
+        auto it_in_set = key_image_set.find(actual_hash);
+        CHECK_AND_ASSERT_MES(it_in_set != key_image_set.end(), false, "transaction id not found in key_image set, img=" << txin.k_image << ENDL
+                << "transaction id = " << actual_hash);
+        key_image_set.erase(it_in_set);
+        if(!key_image_set.size())
+          {
+            //it is now empty hash container for this key_image
+            m_spent_key_images.erase(it);
+          }
+      }
+    }
+    else if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(const txin_v& vi: tx.vin)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(vi, const txin_offshore, txin, false);
+	  auto it = m_spent_key_images.find(txin.k_image);
+	  CHECK_AND_ASSERT_MES(it != m_spent_key_images.end(), false, "failed to find transaction input in key images. img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+	  std::unordered_set<crypto::hash>& key_image_set =  it->second;
+	  CHECK_AND_ASSERT_MES(key_image_set.size(), false, "empty key_image set, img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+
+	  auto it_in_set = key_image_set.find(actual_hash);
+	  CHECK_AND_ASSERT_MES(it_in_set != key_image_set.end(), false, "transaction id not found in key_image set, img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+	  key_image_set.erase(it_in_set);
+	  if(!key_image_set.size())
+	    {
+	      //it is now empty hash container for this key_image
+	      m_spent_key_images.erase(it);
+	    }
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_xasset)) {
+      for(const txin_v& vi: tx.vin)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(vi, const txin_xasset, txin, false);
+	  auto it = m_spent_key_images.find(txin.k_image);
+	  CHECK_AND_ASSERT_MES(it != m_spent_key_images.end(), false, "failed to find transaction input in key images. img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+	  std::unordered_set<crypto::hash>& key_image_set =  it->second;
+	  CHECK_AND_ASSERT_MES(key_image_set.size(), false, "empty key_image set, img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+
+	  auto it_in_set = key_image_set.find(actual_hash);
+	  CHECK_AND_ASSERT_MES(it_in_set != key_image_set.end(), false, "transaction id not found in key_image set, img=" << txin.k_image << ENDL
+			       << "transaction id = " << actual_hash);
+	  key_image_set.erase(it_in_set);
+	  if(!key_image_set.size())
+	    {
+	      //it is now empty hash container for this key_image
+	      m_spent_key_images.erase(it);
+	    }
+	}
+    }
+    else {
+      for(const txin_v& vi: tx.vin)
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(vi, const txin_to_key, txin, false);
+        auto it = m_spent_key_images.find(txin.k_image);
+        CHECK_AND_ASSERT_MES(it != m_spent_key_images.end(), false, "failed to find transaction input in key images. img=" << txin.k_image << ENDL
+                << "transaction id = " << actual_hash);
+        std::unordered_set<crypto::hash>& key_image_set =  it->second;
+        CHECK_AND_ASSERT_MES(key_image_set.size(), false, "empty key_image set, img=" << txin.k_image << ENDL
+                << "transaction id = " << actual_hash);
+
+        auto it_in_set = key_image_set.find(actual_hash);
+        CHECK_AND_ASSERT_MES(it_in_set != key_image_set.end(), false, "transaction id not found in key_image set, img=" << txin.k_image << ENDL
+                << "transaction id = " << actual_hash);
+        key_image_set.erase(it_in_set);
+        if(!key_image_set.size())
+        {
+          //it is now empty hash container for this key_image
+          m_spent_key_images.erase(it);
+        }
       }
-
     }
     ++m_cookie;
     return true;
   }
   //---------------------------------------------------------------------------------
-  bool tx_memory_pool::take_tx(const crypto::hash &id, transaction &tx, cryptonote::blobdata &txblob, size_t& tx_weight, uint64_t& fee, bool &relayed, bool &do_not_relay, bool &double_spend_seen, bool &pruned)
+  bool tx_memory_pool::take_tx(const crypto::hash &id, transaction &tx, cryptonote::blobdata &txblob, size_t& tx_weight, uint64_t& fee, uint64_t& offshore_fee, std::string& fee_asset_type, bool &relayed, bool &do_not_relay, bool &double_spend_seen, bool &pruned)
   {
     CRITICAL_REGION_LOCAL(m_transactions_lock);
     CRITICAL_REGION_LOCAL1(m_blockchain);
@@ -533,6 +901,8 @@ namespace cryptonote
       }
       tx_weight = meta.weight;
       fee = meta.fee;
+      offshore_fee = meta.offshore_fee;
+      fee_asset_type = meta.fee_asset_type;
       relayed = meta.relayed;
       do_not_relay = meta.do_not_relay;
       double_spend_seen = meta.double_spend_seen;
@@ -728,7 +1098,7 @@ namespace cryptonote
     txs.reserve(m_blockchain.get_txpool_tx_count());
     m_blockchain.for_all_txpool_txes([this, now, &txs](const crypto::hash &txid, const txpool_tx_meta_t &meta, const cryptonote::blobdata *){
       // 0 fee transactions are never relayed
-      if(!meta.pruned && meta.fee > 0 && !meta.do_not_relay)
+				       if(!meta.pruned && (meta.fee > 0))
       {
         if (!meta.dandelionpp_stem && now - meta.last_relayed_time <= get_relay_delay(now, meta.receive_time))
           return true;
@@ -1102,11 +1472,37 @@ namespace cryptonote
   {
     CRITICAL_REGION_LOCAL(m_transactions_lock);
     CRITICAL_REGION_LOCAL1(m_blockchain);
-    for(const auto& in: tx.vin)
-    {
-      CHECKED_GET_SPECIFIC_VARIANT(in, const txin_to_key, tokey_in, true);//should never fail
-      if(have_tx_keyimg_as_spent(tokey_in.k_image, txid))
-         return true;
+    if (tx.vin[0].type() == typeid(txin_to_key)) {
+      for(const auto& in: tx.vin)
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(in, const txin_to_key, tokey_in, true);//should never fail
+        if(have_tx_keyimg_as_spent(tokey_in.k_image, txid))
+          return true;
+      }
+    }
+    else if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(const auto& in: tx.vin)
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(in, const txin_offshore, tokey_in, true);//should never fail
+        if(have_tx_keyimg_as_spent(tokey_in.k_image, txid))
+          return true;
+      }
+    }
+    else if (tx.vin[0].type() == typeid(txin_onshore)) {
+      for(const auto& in: tx.vin)
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(in, const txin_onshore, tokey_in, true);//should never fail
+        if(have_tx_keyimg_as_spent(tokey_in.k_image, txid))
+          return true;
+      }
+    }
+    else if (tx.vin[0].type() == typeid(txin_xasset)) {
+      for(const auto& in: tx.vin)
+      {
+        CHECKED_GET_SPECIFIC_VARIANT(in, const txin_xasset, tokey_in, true);//should never fail
+        if(have_tx_keyimg_as_spent(tokey_in.k_image, txid))
+          return true;
+      }
     }
     return false;
   }
@@ -1224,22 +1620,74 @@ namespace cryptonote
   //---------------------------------------------------------------------------------
   bool tx_memory_pool::have_key_images(const std::unordered_set<crypto::key_image>& k_images, const transaction_prefix& tx)
   {
-    for(size_t i = 0; i!= tx.vin.size(); i++)
-    {
-      CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_to_key, itk, false);
-      if(k_images.count(itk.k_image))
-        return true;
+    if (tx.vin[0].type() == typeid(txin_to_key)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_to_key, itk, false);
+	  if(k_images.count(itk.k_image))
+	    return true;
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_offshore, itk, false);
+	  if(k_images.count(itk.k_image))
+	    return true;
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_onshore)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_onshore, itk, false);
+	  if(k_images.count(itk.k_image))
+	    return true;
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_xasset)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_xasset, itk, false);
+	  if(k_images.count(itk.k_image))
+	    return true;
+	}
     }
     return false;
   }
   //---------------------------------------------------------------------------------
   bool tx_memory_pool::append_key_images(std::unordered_set<crypto::key_image>& k_images, const transaction_prefix& tx)
   {
-    for(size_t i = 0; i!= tx.vin.size(); i++)
-    {
-      CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_to_key, itk, false);
-      auto i_res = k_images.insert(itk.k_image);
-      CHECK_AND_ASSERT_MES(i_res.second, false, "internal error: key images pool cache - inserted duplicate image in set: " << itk.k_image);
+    if (tx.vin[0].type() == typeid(txin_to_key)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_to_key, itk, false);
+	  auto i_res = k_images.insert(itk.k_image);
+	  CHECK_AND_ASSERT_MES(i_res.second, false, "internal error: key images pool cache - inserted duplicate image in set: " << itk.k_image);
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_offshore)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_offshore, itk, false);
+	  auto i_res = k_images.insert(itk.k_image);
+	  CHECK_AND_ASSERT_MES(i_res.second, false, "internal error: key images pool cache - inserted duplicate image in set: " << itk.k_image);
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_onshore)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_onshore, itk, false);
+	  auto i_res = k_images.insert(itk.k_image);
+	  CHECK_AND_ASSERT_MES(i_res.second, false, "internal error: key images pool cache - inserted duplicate image in set: " << itk.k_image);
+	}
+    }
+    else if (tx.vin[0].type() == typeid(txin_xasset)) {
+      for(size_t i = 0; i!= tx.vin.size(); i++)
+	{
+	  CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_xasset, itk, false);
+	  auto i_res = k_images.insert(itk.k_image);
+	  CHECK_AND_ASSERT_MES(i_res.second, false, "internal error: key images pool cache - inserted duplicate image in set: " << itk.k_image);
+	}
     }
     return true;
   }
@@ -1252,8 +1700,21 @@ namespace cryptonote
     LockedTXN lock(m_blockchain.get_db());
     for(size_t i = 0; i!= tx.vin.size(); i++)
     {
-      CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_to_key, itk, void());
-      const key_images_container::const_iterator it = m_spent_key_images.find(itk.k_image);
+      crypto::key_image itk_key_image;
+      if (tx.vin[i].type() == typeid(txin_to_key)) {
+	CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_to_key, itk, void());
+        itk_key_image = itk.k_image;
+      } else if (tx.vin[i].type() == typeid(txin_onshore)) {
+	CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_onshore, itk, void());
+        itk_key_image = itk.k_image;
+      } else if (tx.vin[i].type() == typeid(txin_xasset)) {
+	CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_xasset, itk, void());
+        itk_key_image = itk.k_image;
+      } else {
+	CHECKED_GET_SPECIFIC_VARIANT(tx.vin[i], const txin_offshore, itk, void());
+        itk_key_image = itk.k_image;
+      }
+      const key_images_container::const_iterator it = m_spent_key_images.find(itk_key_image);
       if (it != m_spent_key_images.end())
       {
         for (const crypto::hash &txid: it->second)
@@ -1267,7 +1728,7 @@ namespace cryptonote
           }
           if (!meta.double_spend_seen)
           {
-            MDEBUG("Marking " << txid << " as double spending " << itk.k_image);
+            MDEBUG("Marking " << txid << " as double spending " << itk_key_image);
             meta.double_spend_seen = true;
             changed = true;
             try
@@ -1321,14 +1782,13 @@ namespace cryptonote
   }
   //---------------------------------------------------------------------------------
   //TODO: investigate whether boolean return is appropriate
-  bool tx_memory_pool::fill_block_template(block &bl, size_t median_weight, uint64_t already_generated_coins, size_t &total_weight, uint64_t &fee, uint64_t &expected_reward, uint8_t version)
+  bool tx_memory_pool::fill_block_template(block &bl, size_t median_weight, uint64_t already_generated_coins, size_t &total_weight, std::map<std::string, uint64_t> &fee_map, std::map<std::string, uint64_t> &offshore_fee_map, uint64_t &expected_reward, uint8_t version)
   {
     CRITICAL_REGION_LOCAL(m_transactions_lock);
     CRITICAL_REGION_LOCAL1(m_blockchain);
 
     uint64_t best_coinbase = 0, coinbase = 0;
     total_weight = 0;
-    fee = 0;
     
     //baseline empty block
     if (!get_block_reward(median_weight, total_weight, already_generated_coins, best_coinbase, version))
@@ -1337,7 +1797,6 @@ namespace cryptonote
       return false;
     }
 
-
     size_t max_total_weight_pre_v5 = (130 * median_weight) / 100 - CRYPTONOTE_COINBASE_BLOB_RESERVED_SIZE;
     size_t max_total_weight_v5 = 2 * median_weight - CRYPTONOTE_COINBASE_BLOB_RESERVED_SIZE;
     size_t max_total_weight = version >= 5 ? max_total_weight_v5 : max_total_weight_pre_v5;
@@ -1361,7 +1820,9 @@ namespace cryptonote
       if (!meta.matches(relay_category::legacy) && !(m_mine_stem_txes && meta.get_relay_method() == relay_method::stem))
       {
         LOG_PRINT_L2("  tx relay method is " << (unsigned)meta.get_relay_method());
-        continue;
+        // HERE BE DRAGONS!!!
+        //continue;
+        // LAND AHOY!!!
       }
       if (meta.pruned)
       {
@@ -1387,8 +1848,15 @@ namespace cryptonote
           LOG_PRINT_L2("  would exceed maximum block weight");
           continue;
         }
-        coinbase = block_reward + fee + meta.fee;
-        if (coinbase < template_accept_threshold(best_coinbase))
+        if (strcmp(meta.fee_asset_type, "XHV") == 0) {
+          coinbase = block_reward + fee_map["XHV"] + meta.fee;
+        } else {
+          coinbase = block_reward + fee_map["XHV"];
+        }
+	      /*
+          if (coinbase < template_accept_threshold(best_coinbase))
+        */
+        if (coinbase < best_coinbase)
         {
           LOG_PRINT_L2("  would decrease coinbase to " << print_money(coinbase));
           continue;
@@ -1427,14 +1895,14 @@ namespace cryptonote
       if (memcmp(&original_meta, &meta, sizeof(meta)))
       {
         try
-	{
-	  m_blockchain.update_txpool_tx(sorted_it->second, meta);
-	}
+        {
+          m_blockchain.update_txpool_tx(sorted_it->second, meta);
+        }
         catch (const std::exception &e)
-	{
-	  MERROR("Failed to update tx meta: " << e.what());
-	  // continue, not fatal
-	}
+        {
+          MERROR("Failed to update tx meta: " << e.what());
+          // continue, not fatal
+        }
       }
       if (!ready)
       {
@@ -1447,9 +1915,20 @@ namespace cryptonote
         continue;
       }
 
+      // Validate that pricing record has not grown too old since it was first included in the pool
+      if (tx.pricing_record_height > 0)
+      {
+        uint64_t current_height = m_blockchain.get_current_blockchain_height();
+        if ((current_height - PRICING_RECORD_VALID_BLOCKS) > tx.pricing_record_height) {
+          LOG_PRINT_L2("error : offshore/xAsset transaction references a pricing record that is too old (height " << tx.pricing_record_height << ")");
+          continue;
+        }
+      }
+
       bl.tx_hashes.push_back(sorted_it->second);
       total_weight += meta.weight;
-      fee += meta.fee;
+      fee_map[meta.fee_asset_type] += meta.fee;
+      offshore_fee_map[meta.fee_asset_type] += meta.offshore_fee;
       best_coinbase = coinbase;
       append_key_images(k_images, tx);
       LOG_PRINT_L2("  added, new block weight " << total_weight << "/" << max_total_weight << ", coinbase " << print_money(best_coinbase));
@@ -1457,9 +1936,12 @@ namespace cryptonote
     lock.commit();
 
     expected_reward = best_coinbase;
+    // HERE BE DRAGONS!!!
+    // NEAC: add in a function to iteratively output all currencies in a map as money - should live in cryptonote_tx_utils.cpp as a helper fn
     LOG_PRINT_L2("Block template filled with " << bl.tx_hashes.size() << " txes, weight "
         << total_weight << "/" << max_total_weight << ", coinbase " << print_money(best_coinbase)
-        << " (including " << print_money(fee) << " in fees)");
+        << " (including " << print_money(fee_map["XHV"]) << " in fees)");
+    // LAND AHOY!!!
     return true;
   }
   //---------------------------------------------------------------------------------
